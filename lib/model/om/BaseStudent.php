<?php

/**
 * Base class that represents a row from the 'student' table.
 *
 * Representa un alumno
 *
 * This class was autogenerated by Propel 1.3.0-dev on:
 *
 * Thu Aug 23 21:09:10 2018
 *
 * @package    lib.model.om
 */
abstract class BaseStudent extends BaseObject  implements Persistent {


  const PEER = 'StudentPeer';

	/**
	 * The Peer class.
	 * Instance provides a convenient way of calling static methods on a class
	 * that calling code may not be able to identify.
	 * @var        StudentPeer
	 */
	protected static $peer;

	/**
	 * The value for the id field.
	 * @var        int
	 */
	protected $id;

	/**
	 * The value for the global_file_number field.
	 * @var        string
	 */
	protected $global_file_number;

	/**
	 * The value for the order_of_merit field.
	 * @var        string
	 */
	protected $order_of_merit;

	/**
	 * The value for the year_income field.
	 * @var        string
	 */
	protected $year_income;

	/**
	 * The value for the nationality field.
	 * Note: this column has a database default value of: 0
	 * @var        int
	 */
	protected $nationality;

	/**
	 * The value for the folio_number field.
	 * @var        string
	 */
	protected $folio_number;

	/**
	 * The value for the person_id field.
	 * @var        int
	 */
	protected $person_id;

	/**
	 * The value for the occupation_id field.
	 * Note: this column has a database default value of: 0
	 * @var        int
	 */
	protected $occupation_id;

	/**
	 * The value for the busy_starts_at field.
	 * @var        string
	 */
	protected $busy_starts_at;

	/**
	 * The value for the busy_ends_at field.
	 * @var        string
	 */
	protected $busy_ends_at;

	/**
	 * The value for the blood_group field.
	 * @var        string
	 */
	protected $blood_group;

	/**
	 * The value for the blood_factor field.
	 * @var        string
	 */
	protected $blood_factor;

	/**
	 * The value for the emergency_information field.
	 * @var        string
	 */
	protected $emergency_information;

	/**
	 * The value for the health_coverage_id field.
	 * Note: this column has a database default value of: 0
	 * @var        int
	 */
	protected $health_coverage_id;

	/**
	 * The value for the origin_school field.
	 * @var        string
	 */
	protected $origin_school;

	/**
	 * The value for the educational_dependency field.
	 * @var        string
	 */
	protected $educational_dependency;

	/**
	 * @var        Person
	 */
	protected $aPerson;

	/**
	 * @var        Occupation
	 */
	protected $aOccupation;

	/**
	 * @var        HealthCoverage
	 */
	protected $aHealthCoverage;

	/**
	 * @var        array StudentCareerSubjectAllowed[] Collection to store aggregation of StudentCareerSubjectAllowed objects.
	 */
	protected $collStudentCareerSubjectAlloweds;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentCareerSubjectAlloweds.
	 */
	private $lastStudentCareerSubjectAllowedCriteria = null;

	/**
	 * @var        array CourseSubjectStudent[] Collection to store aggregation of CourseSubjectStudent objects.
	 */
	protected $collCourseSubjectStudents;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCourseSubjectStudents.
	 */
	private $lastCourseSubjectStudentCriteria = null;

	/**
	 * @var        array StudentApprovedCareerSubject[] Collection to store aggregation of StudentApprovedCareerSubject objects.
	 */
	protected $collStudentApprovedCareerSubjects;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentApprovedCareerSubjects.
	 */
	private $lastStudentApprovedCareerSubjectCriteria = null;

	/**
	 * @var        array StudentApprovedCourseSubject[] Collection to store aggregation of StudentApprovedCourseSubject objects.
	 */
	protected $collStudentApprovedCourseSubjects;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentApprovedCourseSubjects.
	 */
	private $lastStudentApprovedCourseSubjectCriteria = null;

	/**
	 * @var        array StudentStudy[] Collection to store aggregation of StudentStudy objects.
	 */
	protected $collStudentStudys;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentStudys.
	 */
	private $lastStudentStudyCriteria = null;

	/**
	 * @var        array StudentAttendance[] Collection to store aggregation of StudentAttendance objects.
	 */
	protected $collStudentAttendances;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentAttendances.
	 */
	private $lastStudentAttendanceCriteria = null;

	/**
	 * @var        array StudentReincorporation[] Collection to store aggregation of StudentReincorporation objects.
	 */
	protected $collStudentReincorporations;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentReincorporations.
	 */
	private $lastStudentReincorporationCriteria = null;

	/**
	 * @var        array StudentFree[] Collection to store aggregation of StudentFree objects.
	 */
	protected $collStudentFrees;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentFrees.
	 */
	private $lastStudentFreeCriteria = null;

	/**
	 * @var        array PathwayStudent[] Collection to store aggregation of PathwayStudent objects.
	 */
	protected $collPathwayStudents;

	/**
	 * @var        Criteria The criteria used to select the current contents of collPathwayStudents.
	 */
	private $lastPathwayStudentCriteria = null;

	/**
	 * @var        array CourseSubjectStudentPathway[] Collection to store aggregation of CourseSubjectStudentPathway objects.
	 */
	protected $collCourseSubjectStudentPathways;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCourseSubjectStudentPathways.
	 */
	private $lastCourseSubjectStudentPathwayCriteria = null;

	/**
	 * @var        array CareerStudent[] Collection to store aggregation of CareerStudent objects.
	 */
	protected $collCareerStudents;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCareerStudents.
	 */
	private $lastCareerStudentCriteria = null;

	/**
	 * @var        array StudentCareerSchoolYear[] Collection to store aggregation of StudentCareerSchoolYear objects.
	 */
	protected $collStudentCareerSchoolYears;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentCareerSchoolYears.
	 */
	private $lastStudentCareerSchoolYearCriteria = null;

	/**
	 * @var        array SchoolYearStudent[] Collection to store aggregation of SchoolYearStudent objects.
	 */
	protected $collSchoolYearStudents;

	/**
	 * @var        Criteria The criteria used to select the current contents of collSchoolYearStudents.
	 */
	private $lastSchoolYearStudentCriteria = null;

	/**
	 * @var        array DivisionStudent[] Collection to store aggregation of DivisionStudent objects.
	 */
	protected $collDivisionStudents;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDivisionStudents.
	 */
	private $lastDivisionStudentCriteria = null;

	/**
	 * @var        array StudentDisciplinarySanction[] Collection to store aggregation of StudentDisciplinarySanction objects.
	 */
	protected $collStudentDisciplinarySanctions;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentDisciplinarySanctions.
	 */
	private $lastStudentDisciplinarySanctionCriteria = null;

	/**
	 * @var        array Brotherhood[] Collection to store aggregation of Brotherhood objects.
	 */
	protected $collBrotherhoodsRelatedByStudentId;

	/**
	 * @var        Criteria The criteria used to select the current contents of collBrotherhoodsRelatedByStudentId.
	 */
	private $lastBrotherhoodRelatedByStudentIdCriteria = null;

	/**
	 * @var        array Brotherhood[] Collection to store aggregation of Brotherhood objects.
	 */
	protected $collBrotherhoodsRelatedByBrotherId;

	/**
	 * @var        Criteria The criteria used to select the current contents of collBrotherhoodsRelatedByBrotherId.
	 */
	private $lastBrotherhoodRelatedByBrotherIdCriteria = null;

	/**
	 * @var        array StudentTag[] Collection to store aggregation of StudentTag objects.
	 */
	protected $collStudentTags;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentTags.
	 */
	private $lastStudentTagCriteria = null;

	/**
	 * @var        array StudentTutor[] Collection to store aggregation of StudentTutor objects.
	 */
	protected $collStudentTutors;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStudentTutors.
	 */
	private $lastStudentTutorCriteria = null;

	/**
	 * Flag to prevent endless save loop, if this object is referenced
	 * by another object which falls in this transaction.
	 * @var        boolean
	 */
	protected $alreadyInSave = false;

	/**
	 * Flag to prevent endless validation loop, if this object is referenced
	 * by another object which falls in this transaction.
	 * @var        boolean
	 */
	protected $alreadyInValidation = false;

	/**
	 * Initializes internal state of BaseStudent object.
	 * @see        applyDefaults()
	 */
	public function __construct()
	{
		parent::__construct();
		$this->applyDefaultValues();
	}

	/**
	 * Applies default values to this object.
	 * This method should be called from the object's constructor (or
	 * equivalent initialization method).
	 * @see        __construct()
	 */
	public function applyDefaultValues()
	{
		$this->nationality = 0;
		$this->occupation_id = 0;
		$this->health_coverage_id = 0;
	}

	/**
	 * Get the [id] column value.
	 * 
	 * @return     int
	 */
	public function getId()
	{
		return $this->id;
	}

	/**
	 * Get the [global_file_number] column value.
	 * Número de alumno en el colegio (puede que coincida con el numero de alumno de la carrera) depende del behaviour
	 * @return     string
	 */
	public function getGlobalFileNumber()
	{
		return $this->global_file_number;
	}

	/**
	 * Get the [order_of_merit] column value.
	 * Número de orden de merito del alumno
	 * @return     string
	 */
	public function getOrderOfMerit()
	{
		return $this->order_of_merit;
	}

	/**
	 * Get the [optionally formatted] temporal [year_income] column value.
	 * Año de ingreso
	 *
	 * @param      string $format The date/time format string (either date()-style or strftime()-style).
	 *							If format is NULL, then the raw DateTime object will be returned.
	 * @return     mixed Formatted date/time value as string or DateTime object (if format is NULL), NULL if column is NULL, and 0 if column value is 0000-00-00
	 * @throws     PropelException - if unable to parse/validate the date/time value.
	 */
	public function getYearIncome($format = 'Y-m-d')
	{
		if ($this->year_income === null) {
			return null;
		}


		if ($this->year_income === '0000-00-00') {
			// while technically this is not a default value of NULL,
			// this seems to be closest in meaning.
			return null;
		} else {
			try {
				$dt = new DateTime($this->year_income);
			} catch (Exception $x) {
				throw new PropelException("Internally stored date/time/timestamp value could not be converted to DateTime: " . var_export($this->year_income, true), $x);
			}
		}

		if ($format === null) {
			// Because propel.useDateTimeClass is TRUE, we return a DateTime object.
			return $dt;
		} elseif (strpos($format, '%') !== false) {
			return strftime($format, $dt->format('U'));
		} else {
			return $dt->format($format);
		}
	}

	/**
	 * Get the [nationality] column value.
	 * La nacionalidad del estudiante (nativo, naturalizado, extrangero)
	 * @return     int
	 */
	public function getNationality()
	{
		return $this->nationality;
	}

	/**
	 * Get the [folio_number] column value.
	 * Número de folio del alumno
	 * @return     string
	 */
	public function getFolioNumber()
	{
		return $this->folio_number;
	}

	/**
	 * Get the [person_id] column value.
	 * 
	 * @return     int
	 */
	public function getPersonId()
	{
		return $this->person_id;
	}

	/**
	 * Get the [occupation_id] column value.
	 * 
	 * @return     int
	 */
	public function getOccupationId()
	{
		return $this->occupation_id;
	}

	/**
	 * Get the [optionally formatted] temporal [busy_starts_at] column value.
	 * 
	 *
	 * @param      string $format The date/time format string (either date()-style or strftime()-style).
	 *							If format is NULL, then the raw DateTime object will be returned.
	 * @return     mixed Formatted date/time value as string or DateTime object (if format is NULL), NULL if column is NULL
	 * @throws     PropelException - if unable to parse/validate the date/time value.
	 */
	public function getBusyStartsAt($format = 'H:i:s')
	{
		if ($this->busy_starts_at === null) {
			return null;
		}



		try {
			$dt = new DateTime($this->busy_starts_at);
		} catch (Exception $x) {
			throw new PropelException("Internally stored date/time/timestamp value could not be converted to DateTime: " . var_export($this->busy_starts_at, true), $x);
		}

		if ($format === null) {
			// Because propel.useDateTimeClass is TRUE, we return a DateTime object.
			return $dt;
		} elseif (strpos($format, '%') !== false) {
			return strftime($format, $dt->format('U'));
		} else {
			return $dt->format($format);
		}
	}

	/**
	 * Get the [optionally formatted] temporal [busy_ends_at] column value.
	 * 
	 *
	 * @param      string $format The date/time format string (either date()-style or strftime()-style).
	 *							If format is NULL, then the raw DateTime object will be returned.
	 * @return     mixed Formatted date/time value as string or DateTime object (if format is NULL), NULL if column is NULL
	 * @throws     PropelException - if unable to parse/validate the date/time value.
	 */
	public function getBusyEndsAt($format = 'H:i:s')
	{
		if ($this->busy_ends_at === null) {
			return null;
		}



		try {
			$dt = new DateTime($this->busy_ends_at);
		} catch (Exception $x) {
			throw new PropelException("Internally stored date/time/timestamp value could not be converted to DateTime: " . var_export($this->busy_ends_at, true), $x);
		}

		if ($format === null) {
			// Because propel.useDateTimeClass is TRUE, we return a DateTime object.
			return $dt;
		} elseif (strpos($format, '%') !== false) {
			return strftime($format, $dt->format('U'));
		} else {
			return $dt->format($format);
		}
	}

	/**
	 * Get the [blood_group] column value.
	 * 
	 * @return     string
	 */
	public function getBloodGroup()
	{
		return $this->blood_group;
	}

	/**
	 * Get the [blood_factor] column value.
	 * 
	 * @return     string
	 */
	public function getBloodFactor()
	{
		return $this->blood_factor;
	}

	/**
	 * Get the [emergency_information] column value.
	 * 
	 * @return     string
	 */
	public function getEmergencyInformation()
	{
		return $this->emergency_information;
	}

	/**
	 * Get the [health_coverage_id] column value.
	 * 
	 * @return     int
	 */
	public function getHealthCoverageId()
	{
		return $this->health_coverage_id;
	}

	/**
	 * Get the [origin_school] column value.
	 * 
	 * @return     string
	 */
	public function getOriginSchool()
	{
		return $this->origin_school;
	}

	/**
	 * Get the [educational_dependency] column value.
	 * 
	 * @return     string
	 */
	public function getEducationalDependency()
	{
		return $this->educational_dependency;
	}

	/**
	 * Set the value of [id] column.
	 * 
	 * @param      int $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setId($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->id !== $v) {
			$this->id = $v;
			$this->modifiedColumns[] = StudentPeer::ID;
		}

		return $this;
	} // setId()

	/**
	 * Set the value of [global_file_number] column.
	 * Número de alumno en el colegio (puede que coincida con el numero de alumno de la carrera) depende del behaviour
	 * @param      string $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setGlobalFileNumber($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->global_file_number !== $v) {
			$this->global_file_number = $v;
			$this->modifiedColumns[] = StudentPeer::GLOBAL_FILE_NUMBER;
		}

		return $this;
	} // setGlobalFileNumber()

	/**
	 * Set the value of [order_of_merit] column.
	 * Número de orden de merito del alumno
	 * @param      string $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setOrderOfMerit($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->order_of_merit !== $v) {
			$this->order_of_merit = $v;
			$this->modifiedColumns[] = StudentPeer::ORDER_OF_MERIT;
		}

		return $this;
	} // setOrderOfMerit()

	/**
	 * Sets the value of [year_income] column to a normalized version of the date/time value specified.
	 * Año de ingreso
	 * @param      mixed $v string, integer (timestamp), or DateTime value.  Empty string will
	 *						be treated as NULL for temporal objects.
	 * @return     Student The current object (for fluent API support)
	 */
	public function setYearIncome($v)
	{
		// we treat '' as NULL for temporal objects because DateTime('') == DateTime('now')
		// -- which is unexpected, to say the least.
		if ($v === null || $v === '') {
			$dt = null;
		} elseif ($v instanceof DateTime) {
			$dt = $v;
		} else {
			// some string/numeric value passed; we normalize that so that we can
			// validate it.
			try {
				if (is_numeric($v)) { // if it's a unix timestamp
					$dt = new DateTime('@'.$v, new DateTimeZone('UTC'));
					// We have to explicitly specify and then change the time zone because of a
					// DateTime bug: http://bugs.php.net/bug.php?id=43003
					$dt->setTimeZone(new DateTimeZone(date_default_timezone_get()));
				} else {
					$dt = new DateTime($v);
				}
			} catch (Exception $x) {
				throw new PropelException('Error parsing date/time value: ' . var_export($v, true), $x);
			}
		}

		if ( $this->year_income !== null || $dt !== null ) {
			// (nested ifs are a little easier to read in this case)

			$currNorm = ($this->year_income !== null && $tmpDt = new DateTime($this->year_income)) ? $tmpDt->format('Y-m-d') : null;
			$newNorm = ($dt !== null) ? $dt->format('Y-m-d') : null;

			if ( ($currNorm !== $newNorm) // normalized values don't match 
					)
			{
				$this->year_income = ($dt ? $dt->format('Y-m-d') : null);
				$this->modifiedColumns[] = StudentPeer::YEAR_INCOME;
			}
		} // if either are not null

		return $this;
	} // setYearIncome()

	/**
	 * Set the value of [nationality] column.
	 * La nacionalidad del estudiante (nativo, naturalizado, extrangero)
	 * @param      int $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setNationality($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->nationality !== $v || $v === 0) {
			$this->nationality = $v;
			$this->modifiedColumns[] = StudentPeer::NATIONALITY;
		}

		return $this;
	} // setNationality()

	/**
	 * Set the value of [folio_number] column.
	 * Número de folio del alumno
	 * @param      string $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setFolioNumber($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->folio_number !== $v) {
			$this->folio_number = $v;
			$this->modifiedColumns[] = StudentPeer::FOLIO_NUMBER;
		}

		return $this;
	} // setFolioNumber()

	/**
	 * Set the value of [person_id] column.
	 * 
	 * @param      int $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setPersonId($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->person_id !== $v) {
			$this->person_id = $v;
			$this->modifiedColumns[] = StudentPeer::PERSON_ID;
		}

		if ($this->aPerson !== null && $this->aPerson->getId() !== $v) {
			$this->aPerson = null;
		}

		return $this;
	} // setPersonId()

	/**
	 * Set the value of [occupation_id] column.
	 * 
	 * @param      int $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setOccupationId($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->occupation_id !== $v || $v === 0) {
			$this->occupation_id = $v;
			$this->modifiedColumns[] = StudentPeer::OCCUPATION_ID;
		}

		if ($this->aOccupation !== null && $this->aOccupation->getId() !== $v) {
			$this->aOccupation = null;
		}

		return $this;
	} // setOccupationId()

	/**
	 * Sets the value of [busy_starts_at] column to a normalized version of the date/time value specified.
	 * 
	 * @param      mixed $v string, integer (timestamp), or DateTime value.  Empty string will
	 *						be treated as NULL for temporal objects.
	 * @return     Student The current object (for fluent API support)
	 */
	public function setBusyStartsAt($v)
	{
		// we treat '' as NULL for temporal objects because DateTime('') == DateTime('now')
		// -- which is unexpected, to say the least.
		if ($v === null || $v === '') {
			$dt = null;
		} elseif ($v instanceof DateTime) {
			$dt = $v;
		} else {
			// some string/numeric value passed; we normalize that so that we can
			// validate it.
			try {
				if (is_numeric($v)) { // if it's a unix timestamp
					$dt = new DateTime('@'.$v, new DateTimeZone('UTC'));
					// We have to explicitly specify and then change the time zone because of a
					// DateTime bug: http://bugs.php.net/bug.php?id=43003
					$dt->setTimeZone(new DateTimeZone(date_default_timezone_get()));
				} else {
					$dt = new DateTime($v);
				}
			} catch (Exception $x) {
				throw new PropelException('Error parsing date/time value: ' . var_export($v, true), $x);
			}
		}

		if ( $this->busy_starts_at !== null || $dt !== null ) {
			// (nested ifs are a little easier to read in this case)

			$currNorm = ($this->busy_starts_at !== null && $tmpDt = new DateTime($this->busy_starts_at)) ? $tmpDt->format('H:i:s') : null;
			$newNorm = ($dt !== null) ? $dt->format('H:i:s') : null;

			if ( ($currNorm !== $newNorm) // normalized values don't match 
					)
			{
				$this->busy_starts_at = ($dt ? $dt->format('H:i:s') : null);
				$this->modifiedColumns[] = StudentPeer::BUSY_STARTS_AT;
			}
		} // if either are not null

		return $this;
	} // setBusyStartsAt()

	/**
	 * Sets the value of [busy_ends_at] column to a normalized version of the date/time value specified.
	 * 
	 * @param      mixed $v string, integer (timestamp), or DateTime value.  Empty string will
	 *						be treated as NULL for temporal objects.
	 * @return     Student The current object (for fluent API support)
	 */
	public function setBusyEndsAt($v)
	{
		// we treat '' as NULL for temporal objects because DateTime('') == DateTime('now')
		// -- which is unexpected, to say the least.
		if ($v === null || $v === '') {
			$dt = null;
		} elseif ($v instanceof DateTime) {
			$dt = $v;
		} else {
			// some string/numeric value passed; we normalize that so that we can
			// validate it.
			try {
				if (is_numeric($v)) { // if it's a unix timestamp
					$dt = new DateTime('@'.$v, new DateTimeZone('UTC'));
					// We have to explicitly specify and then change the time zone because of a
					// DateTime bug: http://bugs.php.net/bug.php?id=43003
					$dt->setTimeZone(new DateTimeZone(date_default_timezone_get()));
				} else {
					$dt = new DateTime($v);
				}
			} catch (Exception $x) {
				throw new PropelException('Error parsing date/time value: ' . var_export($v, true), $x);
			}
		}

		if ( $this->busy_ends_at !== null || $dt !== null ) {
			// (nested ifs are a little easier to read in this case)

			$currNorm = ($this->busy_ends_at !== null && $tmpDt = new DateTime($this->busy_ends_at)) ? $tmpDt->format('H:i:s') : null;
			$newNorm = ($dt !== null) ? $dt->format('H:i:s') : null;

			if ( ($currNorm !== $newNorm) // normalized values don't match 
					)
			{
				$this->busy_ends_at = ($dt ? $dt->format('H:i:s') : null);
				$this->modifiedColumns[] = StudentPeer::BUSY_ENDS_AT;
			}
		} // if either are not null

		return $this;
	} // setBusyEndsAt()

	/**
	 * Set the value of [blood_group] column.
	 * 
	 * @param      string $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setBloodGroup($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->blood_group !== $v) {
			$this->blood_group = $v;
			$this->modifiedColumns[] = StudentPeer::BLOOD_GROUP;
		}

		return $this;
	} // setBloodGroup()

	/**
	 * Set the value of [blood_factor] column.
	 * 
	 * @param      string $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setBloodFactor($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->blood_factor !== $v) {
			$this->blood_factor = $v;
			$this->modifiedColumns[] = StudentPeer::BLOOD_FACTOR;
		}

		return $this;
	} // setBloodFactor()

	/**
	 * Set the value of [emergency_information] column.
	 * 
	 * @param      string $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setEmergencyInformation($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->emergency_information !== $v) {
			$this->emergency_information = $v;
			$this->modifiedColumns[] = StudentPeer::EMERGENCY_INFORMATION;
		}

		return $this;
	} // setEmergencyInformation()

	/**
	 * Set the value of [health_coverage_id] column.
	 * 
	 * @param      int $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setHealthCoverageId($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->health_coverage_id !== $v || $v === 0) {
			$this->health_coverage_id = $v;
			$this->modifiedColumns[] = StudentPeer::HEALTH_COVERAGE_ID;
		}

		if ($this->aHealthCoverage !== null && $this->aHealthCoverage->getId() !== $v) {
			$this->aHealthCoverage = null;
		}

		return $this;
	} // setHealthCoverageId()

	/**
	 * Set the value of [origin_school] column.
	 * 
	 * @param      string $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setOriginSchool($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->origin_school !== $v) {
			$this->origin_school = $v;
			$this->modifiedColumns[] = StudentPeer::ORIGIN_SCHOOL;
		}

		return $this;
	} // setOriginSchool()

	/**
	 * Set the value of [educational_dependency] column.
	 * 
	 * @param      string $v new value
	 * @return     Student The current object (for fluent API support)
	 */
	public function setEducationalDependency($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->educational_dependency !== $v) {
			$this->educational_dependency = $v;
			$this->modifiedColumns[] = StudentPeer::EDUCATIONAL_DEPENDENCY;
		}

		return $this;
	} // setEducationalDependency()

	/**
	 * Indicates whether the columns in this object are only set to default values.
	 *
	 * This method can be used in conjunction with isModified() to indicate whether an object is both
	 * modified _and_ has some values set which are non-default.
	 *
	 * @return     boolean Whether the columns in this object are only been set with default values.
	 */
	public function hasOnlyDefaultValues()
	{
			// First, ensure that we don't have any columns that have been modified which aren't default columns.
			if (array_diff($this->modifiedColumns, array(StudentPeer::NATIONALITY,StudentPeer::OCCUPATION_ID,StudentPeer::HEALTH_COVERAGE_ID))) {
				return false;
			}

			if ($this->nationality !== 0) {
				return false;
			}

			if ($this->occupation_id !== 0) {
				return false;
			}

			if ($this->health_coverage_id !== 0) {
				return false;
			}

		// otherwise, everything was equal, so return TRUE
		return true;
	} // hasOnlyDefaultValues()

	/**
	 * Hydrates (populates) the object variables with values from the database resultset.
	 *
	 * An offset (0-based "start column") is specified so that objects can be hydrated
	 * with a subset of the columns in the resultset rows.  This is needed, for example,
	 * for results of JOIN queries where the resultset row includes columns from two or
	 * more tables.
	 *
	 * @param      array $row The row returned by PDOStatement->fetch(PDO::FETCH_NUM)
	 * @param      int $startcol 0-based offset column which indicates which restultset column to start with.
	 * @param      boolean $rehydrate Whether this object is being re-hydrated from the database.
	 * @return     int next starting column
	 * @throws     PropelException  - Any caught Exception will be rewrapped as a PropelException.
	 */
	public function hydrate($row, $startcol = 0, $rehydrate = false)
	{
		try {

			$this->id = ($row[$startcol + 0] !== null) ? (int) $row[$startcol + 0] : null;
			$this->global_file_number = ($row[$startcol + 1] !== null) ? (string) $row[$startcol + 1] : null;
			$this->order_of_merit = ($row[$startcol + 2] !== null) ? (string) $row[$startcol + 2] : null;
			$this->year_income = ($row[$startcol + 3] !== null) ? (string) $row[$startcol + 3] : null;
			$this->nationality = ($row[$startcol + 4] !== null) ? (int) $row[$startcol + 4] : null;
			$this->folio_number = ($row[$startcol + 5] !== null) ? (string) $row[$startcol + 5] : null;
			$this->person_id = ($row[$startcol + 6] !== null) ? (int) $row[$startcol + 6] : null;
			$this->occupation_id = ($row[$startcol + 7] !== null) ? (int) $row[$startcol + 7] : null;
			$this->busy_starts_at = ($row[$startcol + 8] !== null) ? (string) $row[$startcol + 8] : null;
			$this->busy_ends_at = ($row[$startcol + 9] !== null) ? (string) $row[$startcol + 9] : null;
			$this->blood_group = ($row[$startcol + 10] !== null) ? (string) $row[$startcol + 10] : null;
			$this->blood_factor = ($row[$startcol + 11] !== null) ? (string) $row[$startcol + 11] : null;
			$this->emergency_information = ($row[$startcol + 12] !== null) ? (string) $row[$startcol + 12] : null;
			$this->health_coverage_id = ($row[$startcol + 13] !== null) ? (int) $row[$startcol + 13] : null;
			$this->origin_school = ($row[$startcol + 14] !== null) ? (string) $row[$startcol + 14] : null;
			$this->educational_dependency = ($row[$startcol + 15] !== null) ? (string) $row[$startcol + 15] : null;
			$this->resetModified();

			$this->setNew(false);

			if ($rehydrate) {
				$this->ensureConsistency();
			}

			// FIXME - using NUM_COLUMNS may be clearer.
			return $startcol + 16; // 16 = StudentPeer::NUM_COLUMNS - StudentPeer::NUM_LAZY_LOAD_COLUMNS).

		} catch (Exception $e) {
			throw new PropelException("Error populating Student object", $e);
		}
	}

	/**
	 * Checks and repairs the internal consistency of the object.
	 *
	 * This method is executed after an already-instantiated object is re-hydrated
	 * from the database.  It exists to check any foreign keys to make sure that
	 * the objects related to the current object are correct based on foreign key.
	 *
	 * You can override this method in the stub class, but you should always invoke
	 * the base method from the overridden method (i.e. parent::ensureConsistency()),
	 * in case your model changes.
	 *
	 * @throws     PropelException
	 */
	public function ensureConsistency()
	{

		if ($this->aPerson !== null && $this->person_id !== $this->aPerson->getId()) {
			$this->aPerson = null;
		}
		if ($this->aOccupation !== null && $this->occupation_id !== $this->aOccupation->getId()) {
			$this->aOccupation = null;
		}
		if ($this->aHealthCoverage !== null && $this->health_coverage_id !== $this->aHealthCoverage->getId()) {
			$this->aHealthCoverage = null;
		}
	} // ensureConsistency

	/**
	 * Reloads this object from datastore based on primary key and (optionally) resets all associated objects.
	 *
	 * This will only work if the object has been saved and has a valid primary key set.
	 *
	 * @param      boolean $deep (optional) Whether to also de-associated any related objects.
	 * @param      PropelPDO $con (optional) The PropelPDO connection to use.
	 * @return     void
	 * @throws     PropelException - if this object is deleted, unsaved or doesn't have pk match in db
	 */
	public function reload($deep = false, PropelPDO $con = null)
	{
		if ($this->isDeleted()) {
			throw new PropelException("Cannot reload a deleted object.");
		}

		if ($this->isNew()) {
			throw new PropelException("Cannot reload an unsaved object.");
		}

		if ($con === null) {
			$con = Propel::getConnection(StudentPeer::DATABASE_NAME, Propel::CONNECTION_READ);
		}

		// We don't need to alter the object instance pool; we're just modifying this instance
		// already in the pool.

		$stmt = StudentPeer::doSelectStmt($this->buildPkeyCriteria(), $con);
		$row = $stmt->fetch(PDO::FETCH_NUM);
		$stmt->closeCursor();
		if (!$row) {
			throw new PropelException('Cannot find matching row in the database to reload object values.');
		}
		$this->hydrate($row, 0, true); // rehydrate

		if ($deep) {  // also de-associate any related objects?

			$this->aPerson = null;
			$this->aOccupation = null;
			$this->aHealthCoverage = null;
			$this->collStudentCareerSubjectAlloweds = null;
			$this->lastStudentCareerSubjectAllowedCriteria = null;

			$this->collCourseSubjectStudents = null;
			$this->lastCourseSubjectStudentCriteria = null;

			$this->collStudentApprovedCareerSubjects = null;
			$this->lastStudentApprovedCareerSubjectCriteria = null;

			$this->collStudentApprovedCourseSubjects = null;
			$this->lastStudentApprovedCourseSubjectCriteria = null;

			$this->collStudentStudys = null;
			$this->lastStudentStudyCriteria = null;

			$this->collStudentAttendances = null;
			$this->lastStudentAttendanceCriteria = null;

			$this->collStudentReincorporations = null;
			$this->lastStudentReincorporationCriteria = null;

			$this->collStudentFrees = null;
			$this->lastStudentFreeCriteria = null;

			$this->collPathwayStudents = null;
			$this->lastPathwayStudentCriteria = null;

			$this->collCourseSubjectStudentPathways = null;
			$this->lastCourseSubjectStudentPathwayCriteria = null;

			$this->collCareerStudents = null;
			$this->lastCareerStudentCriteria = null;

			$this->collStudentCareerSchoolYears = null;
			$this->lastStudentCareerSchoolYearCriteria = null;

			$this->collSchoolYearStudents = null;
			$this->lastSchoolYearStudentCriteria = null;

			$this->collDivisionStudents = null;
			$this->lastDivisionStudentCriteria = null;

			$this->collStudentDisciplinarySanctions = null;
			$this->lastStudentDisciplinarySanctionCriteria = null;

			$this->collBrotherhoodsRelatedByStudentId = null;
			$this->lastBrotherhoodRelatedByStudentIdCriteria = null;

			$this->collBrotherhoodsRelatedByBrotherId = null;
			$this->lastBrotherhoodRelatedByBrotherIdCriteria = null;

			$this->collStudentTags = null;
			$this->lastStudentTagCriteria = null;

			$this->collStudentTutors = null;
			$this->lastStudentTutorCriteria = null;

		} // if (deep)
	}

	/**
	 * Removes this object from datastore and sets delete attribute.
	 *
	 * @param      PropelPDO $con
	 * @return     void
	 * @throws     PropelException
	 * @see        BaseObject::setDeleted()
	 * @see        BaseObject::isDeleted()
	 */
	public function delete(PropelPDO $con = null)
	{

    foreach (sfMixer::getCallables('BaseStudent:delete:pre') as $callable)
    {
      $ret = call_user_func($callable, $this, $con);
      if ($ret)
      {
        return;
      }
    }


		if ($this->isDeleted()) {
			throw new PropelException("This object has already been deleted.");
		}

		if ($con === null) {
			$con = Propel::getConnection(StudentPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
		}
		
		$con->beginTransaction();
		try {
			StudentPeer::doDelete($this, $con);
			$this->setDeleted(true);
			$con->commit();
		} catch (PropelException $e) {
			$con->rollBack();
			throw $e;
		}
	

    foreach (sfMixer::getCallables('BaseStudent:delete:post') as $callable)
    {
      call_user_func($callable, $this, $con);
    }

  }
	/**
	 * Persists this object to the database.
	 *
	 * If the object is new, it inserts it; otherwise an update is performed.
	 * All modified related objects will also be persisted in the doSave()
	 * method.  This method wraps all precipitate database operations in a
	 * single transaction.
	 *
	 * @param      PropelPDO $con
	 * @return     int The number of rows affected by this insert/update and any referring fk objects' save() operations.
	 * @throws     PropelException
	 * @see        doSave()
	 */
	public function save(PropelPDO $con = null)
	{

    foreach (sfMixer::getCallables('BaseStudent:save:pre') as $callable)
    {
      $affectedRows = call_user_func($callable, $this, $con);
      if (is_int($affectedRows))
      {
        return $affectedRows;
      }
    }


		if ($this->isDeleted()) {
			throw new PropelException("You cannot save an object that has been deleted.");
		}

		if ($con === null) {
			$con = Propel::getConnection(StudentPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
		}
		
		$con->beginTransaction();
		try {
			$affectedRows = $this->doSave($con);
			$con->commit();
    foreach (sfMixer::getCallables('BaseStudent:save:post') as $callable)
    {
      call_user_func($callable, $this, $con, $affectedRows);
    }

			StudentPeer::addInstanceToPool($this);
			return $affectedRows;
		} catch (PropelException $e) {
			$con->rollBack();
			throw $e;
		}
	}

	/**
	 * Performs the work of inserting or updating the row in the database.
	 *
	 * If the object is new, it inserts it; otherwise an update is performed.
	 * All related objects are also updated in this method.
	 *
	 * @param      PropelPDO $con
	 * @return     int The number of rows affected by this insert/update and any referring fk objects' save() operations.
	 * @throws     PropelException
	 * @see        save()
	 */
	protected function doSave(PropelPDO $con)
	{
		$affectedRows = 0; // initialize var to track total num of affected rows
		if (!$this->alreadyInSave) {
			$this->alreadyInSave = true;

			// We call the save method on the following object(s) if they
			// were passed to this object by their coresponding set
			// method.  This object relates to these object(s) by a
			// foreign key reference.

			if ($this->aPerson !== null) {
				if ($this->aPerson->isModified() || $this->aPerson->isNew()) {
					$affectedRows += $this->aPerson->save($con);
				}
				$this->setPerson($this->aPerson);
			}

			if ($this->aOccupation !== null) {
				if ($this->aOccupation->isModified() || $this->aOccupation->isNew()) {
					$affectedRows += $this->aOccupation->save($con);
				}
				$this->setOccupation($this->aOccupation);
			}

			if ($this->aHealthCoverage !== null) {
				if ($this->aHealthCoverage->isModified() || $this->aHealthCoverage->isNew()) {
					$affectedRows += $this->aHealthCoverage->save($con);
				}
				$this->setHealthCoverage($this->aHealthCoverage);
			}

			if ($this->isNew() ) {
				$this->modifiedColumns[] = StudentPeer::ID;
			}

			// If this object has been modified, then save it to the database.
			if ($this->isModified()) {
				if ($this->isNew()) {
					$pk = StudentPeer::doInsert($this, $con);
					$affectedRows += 1; // we are assuming that there is only 1 row per doInsert() which
										 // should always be true here (even though technically
										 // BasePeer::doInsert() can insert multiple rows).

					$this->setId($pk);  //[IMV] update autoincrement primary key

					$this->setNew(false);
				} else {
					$affectedRows += StudentPeer::doUpdate($this, $con);
				}

				$this->resetModified(); // [HL] After being saved an object is no longer 'modified'
			}

			if ($this->collStudentCareerSubjectAlloweds !== null) {
				foreach ($this->collStudentCareerSubjectAlloweds as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCourseSubjectStudents !== null) {
				foreach ($this->collCourseSubjectStudents as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStudentApprovedCareerSubjects !== null) {
				foreach ($this->collStudentApprovedCareerSubjects as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStudentApprovedCourseSubjects !== null) {
				foreach ($this->collStudentApprovedCourseSubjects as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStudentStudys !== null) {
				foreach ($this->collStudentStudys as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStudentAttendances !== null) {
				foreach ($this->collStudentAttendances as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStudentReincorporations !== null) {
				foreach ($this->collStudentReincorporations as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStudentFrees !== null) {
				foreach ($this->collStudentFrees as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collPathwayStudents !== null) {
				foreach ($this->collPathwayStudents as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCourseSubjectStudentPathways !== null) {
				foreach ($this->collCourseSubjectStudentPathways as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCareerStudents !== null) {
				foreach ($this->collCareerStudents as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStudentCareerSchoolYears !== null) {
				foreach ($this->collStudentCareerSchoolYears as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collSchoolYearStudents !== null) {
				foreach ($this->collSchoolYearStudents as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDivisionStudents !== null) {
				foreach ($this->collDivisionStudents as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStudentDisciplinarySanctions !== null) {
				foreach ($this->collStudentDisciplinarySanctions as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collBrotherhoodsRelatedByStudentId !== null) {
				foreach ($this->collBrotherhoodsRelatedByStudentId as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collBrotherhoodsRelatedByBrotherId !== null) {
				foreach ($this->collBrotherhoodsRelatedByBrotherId as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStudentTags !== null) {
				foreach ($this->collStudentTags as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStudentTutors !== null) {
				foreach ($this->collStudentTutors as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			$this->alreadyInSave = false;

		}
		return $affectedRows;
	} // doSave()

	/**
	 * Array of ValidationFailed objects.
	 * @var        array ValidationFailed[]
	 */
	protected $validationFailures = array();

	/**
	 * Gets any ValidationFailed objects that resulted from last call to validate().
	 *
	 *
	 * @return     array ValidationFailed[]
	 * @see        validate()
	 */
	public function getValidationFailures()
	{
		return $this->validationFailures;
	}

	/**
	 * Validates the objects modified field values and all objects related to this table.
	 *
	 * If $columns is either a column name or an array of column names
	 * only those columns are validated.
	 *
	 * @param      mixed $columns Column name or an array of column names.
	 * @return     boolean Whether all columns pass validation.
	 * @see        doValidate()
	 * @see        getValidationFailures()
	 */
	public function validate($columns = null)
	{
		$res = $this->doValidate($columns);
		if ($res === true) {
			$this->validationFailures = array();
			return true;
		} else {
			$this->validationFailures = $res;
			return false;
		}
	}

	/**
	 * This function performs the validation work for complex object models.
	 *
	 * In addition to checking the current object, all related objects will
	 * also be validated.  If all pass then <code>true</code> is returned; otherwise
	 * an aggreagated array of ValidationFailed objects will be returned.
	 *
	 * @param      array $columns Array of column names to validate.
	 * @return     mixed <code>true</code> if all validations pass; array of <code>ValidationFailed</code> objets otherwise.
	 */
	protected function doValidate($columns = null)
	{
		if (!$this->alreadyInValidation) {
			$this->alreadyInValidation = true;
			$retval = null;

			$failureMap = array();


			// We call the validate method on the following object(s) if they
			// were passed to this object by their coresponding set
			// method.  This object relates to these object(s) by a
			// foreign key reference.

			if ($this->aPerson !== null) {
				if (!$this->aPerson->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aPerson->getValidationFailures());
				}
			}

			if ($this->aOccupation !== null) {
				if (!$this->aOccupation->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aOccupation->getValidationFailures());
				}
			}

			if ($this->aHealthCoverage !== null) {
				if (!$this->aHealthCoverage->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aHealthCoverage->getValidationFailures());
				}
			}


			if (($retval = StudentPeer::doValidate($this, $columns)) !== true) {
				$failureMap = array_merge($failureMap, $retval);
			}


				if ($this->collStudentCareerSubjectAlloweds !== null) {
					foreach ($this->collStudentCareerSubjectAlloweds as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCourseSubjectStudents !== null) {
					foreach ($this->collCourseSubjectStudents as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStudentApprovedCareerSubjects !== null) {
					foreach ($this->collStudentApprovedCareerSubjects as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStudentApprovedCourseSubjects !== null) {
					foreach ($this->collStudentApprovedCourseSubjects as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStudentStudys !== null) {
					foreach ($this->collStudentStudys as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStudentAttendances !== null) {
					foreach ($this->collStudentAttendances as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStudentReincorporations !== null) {
					foreach ($this->collStudentReincorporations as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStudentFrees !== null) {
					foreach ($this->collStudentFrees as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collPathwayStudents !== null) {
					foreach ($this->collPathwayStudents as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCourseSubjectStudentPathways !== null) {
					foreach ($this->collCourseSubjectStudentPathways as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCareerStudents !== null) {
					foreach ($this->collCareerStudents as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStudentCareerSchoolYears !== null) {
					foreach ($this->collStudentCareerSchoolYears as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collSchoolYearStudents !== null) {
					foreach ($this->collSchoolYearStudents as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDivisionStudents !== null) {
					foreach ($this->collDivisionStudents as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStudentDisciplinarySanctions !== null) {
					foreach ($this->collStudentDisciplinarySanctions as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collBrotherhoodsRelatedByStudentId !== null) {
					foreach ($this->collBrotherhoodsRelatedByStudentId as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collBrotherhoodsRelatedByBrotherId !== null) {
					foreach ($this->collBrotherhoodsRelatedByBrotherId as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStudentTags !== null) {
					foreach ($this->collStudentTags as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStudentTutors !== null) {
					foreach ($this->collStudentTutors as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}


			$this->alreadyInValidation = false;
		}

		return (!empty($failureMap) ? $failureMap : true);
	}

	/**
	 * Retrieves a field from the object by name passed in as a string.
	 *
	 * @param      string $name name
	 * @param      string $type The type of fieldname the $name is of:
	 *                     one of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                     BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM
	 * @return     mixed Value of field.
	 */
	public function getByName($name, $type = BasePeer::TYPE_PHPNAME)
	{
		$pos = StudentPeer::translateFieldName($name, $type, BasePeer::TYPE_NUM);
		$field = $this->getByPosition($pos);
		return $field;
	}

	/**
	 * Retrieves a field from the object by Position as specified in the xml schema.
	 * Zero-based.
	 *
	 * @param      int $pos position in xml schema
	 * @return     mixed Value of field at $pos
	 */
	public function getByPosition($pos)
	{
		switch($pos) {
			case 0:
				return $this->getId();
				break;
			case 1:
				return $this->getGlobalFileNumber();
				break;
			case 2:
				return $this->getOrderOfMerit();
				break;
			case 3:
				return $this->getYearIncome();
				break;
			case 4:
				return $this->getNationality();
				break;
			case 5:
				return $this->getFolioNumber();
				break;
			case 6:
				return $this->getPersonId();
				break;
			case 7:
				return $this->getOccupationId();
				break;
			case 8:
				return $this->getBusyStartsAt();
				break;
			case 9:
				return $this->getBusyEndsAt();
				break;
			case 10:
				return $this->getBloodGroup();
				break;
			case 11:
				return $this->getBloodFactor();
				break;
			case 12:
				return $this->getEmergencyInformation();
				break;
			case 13:
				return $this->getHealthCoverageId();
				break;
			case 14:
				return $this->getOriginSchool();
				break;
			case 15:
				return $this->getEducationalDependency();
				break;
			default:
				return null;
				break;
		} // switch()
	}

	/**
	 * Exports the object as an array.
	 *
	 * You can specify the key type of the array by passing one of the class
	 * type constants.
	 *
	 * @param      string $keyType (optional) One of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                        BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM. Defaults to BasePeer::TYPE_PHPNAME.
	 * @param      boolean $includeLazyLoadColumns (optional) Whether to include lazy loaded columns.  Defaults to TRUE.
	 * @return     an associative array containing the field names (as keys) and field values
	 */
	public function toArray($keyType = BasePeer::TYPE_PHPNAME, $includeLazyLoadColumns = true)
	{
		$keys = StudentPeer::getFieldNames($keyType);
		$result = array(
			$keys[0] => $this->getId(),
			$keys[1] => $this->getGlobalFileNumber(),
			$keys[2] => $this->getOrderOfMerit(),
			$keys[3] => $this->getYearIncome(),
			$keys[4] => $this->getNationality(),
			$keys[5] => $this->getFolioNumber(),
			$keys[6] => $this->getPersonId(),
			$keys[7] => $this->getOccupationId(),
			$keys[8] => $this->getBusyStartsAt(),
			$keys[9] => $this->getBusyEndsAt(),
			$keys[10] => $this->getBloodGroup(),
			$keys[11] => $this->getBloodFactor(),
			$keys[12] => $this->getEmergencyInformation(),
			$keys[13] => $this->getHealthCoverageId(),
			$keys[14] => $this->getOriginSchool(),
			$keys[15] => $this->getEducationalDependency(),
		);
		return $result;
	}

	/**
	 * Sets a field from the object by name passed in as a string.
	 *
	 * @param      string $name peer name
	 * @param      mixed $value field value
	 * @param      string $type The type of fieldname the $name is of:
	 *                     one of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                     BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM
	 * @return     void
	 */
	public function setByName($name, $value, $type = BasePeer::TYPE_PHPNAME)
	{
		$pos = StudentPeer::translateFieldName($name, $type, BasePeer::TYPE_NUM);
		return $this->setByPosition($pos, $value);
	}

	/**
	 * Sets a field from the object by Position as specified in the xml schema.
	 * Zero-based.
	 *
	 * @param      int $pos position in xml schema
	 * @param      mixed $value field value
	 * @return     void
	 */
	public function setByPosition($pos, $value)
	{
		switch($pos) {
			case 0:
				$this->setId($value);
				break;
			case 1:
				$this->setGlobalFileNumber($value);
				break;
			case 2:
				$this->setOrderOfMerit($value);
				break;
			case 3:
				$this->setYearIncome($value);
				break;
			case 4:
				$this->setNationality($value);
				break;
			case 5:
				$this->setFolioNumber($value);
				break;
			case 6:
				$this->setPersonId($value);
				break;
			case 7:
				$this->setOccupationId($value);
				break;
			case 8:
				$this->setBusyStartsAt($value);
				break;
			case 9:
				$this->setBusyEndsAt($value);
				break;
			case 10:
				$this->setBloodGroup($value);
				break;
			case 11:
				$this->setBloodFactor($value);
				break;
			case 12:
				$this->setEmergencyInformation($value);
				break;
			case 13:
				$this->setHealthCoverageId($value);
				break;
			case 14:
				$this->setOriginSchool($value);
				break;
			case 15:
				$this->setEducationalDependency($value);
				break;
		} // switch()
	}

	/**
	 * Populates the object using an array.
	 *
	 * This is particularly useful when populating an object from one of the
	 * request arrays (e.g. $_POST).  This method goes through the column
	 * names, checking to see whether a matching key exists in populated
	 * array. If so the setByName() method is called for that column.
	 *
	 * You can specify the key type of the array by additionally passing one
	 * of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME,
	 * BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM.
	 * The default key type is the column's phpname (e.g. 'AuthorId')
	 *
	 * @param      array  $arr     An array to populate the object from.
	 * @param      string $keyType The type of keys the array uses.
	 * @return     void
	 */
	public function fromArray($arr, $keyType = BasePeer::TYPE_PHPNAME)
	{
		$keys = StudentPeer::getFieldNames($keyType);

		if (array_key_exists($keys[0], $arr)) $this->setId($arr[$keys[0]]);
		if (array_key_exists($keys[1], $arr)) $this->setGlobalFileNumber($arr[$keys[1]]);
		if (array_key_exists($keys[2], $arr)) $this->setOrderOfMerit($arr[$keys[2]]);
		if (array_key_exists($keys[3], $arr)) $this->setYearIncome($arr[$keys[3]]);
		if (array_key_exists($keys[4], $arr)) $this->setNationality($arr[$keys[4]]);
		if (array_key_exists($keys[5], $arr)) $this->setFolioNumber($arr[$keys[5]]);
		if (array_key_exists($keys[6], $arr)) $this->setPersonId($arr[$keys[6]]);
		if (array_key_exists($keys[7], $arr)) $this->setOccupationId($arr[$keys[7]]);
		if (array_key_exists($keys[8], $arr)) $this->setBusyStartsAt($arr[$keys[8]]);
		if (array_key_exists($keys[9], $arr)) $this->setBusyEndsAt($arr[$keys[9]]);
		if (array_key_exists($keys[10], $arr)) $this->setBloodGroup($arr[$keys[10]]);
		if (array_key_exists($keys[11], $arr)) $this->setBloodFactor($arr[$keys[11]]);
		if (array_key_exists($keys[12], $arr)) $this->setEmergencyInformation($arr[$keys[12]]);
		if (array_key_exists($keys[13], $arr)) $this->setHealthCoverageId($arr[$keys[13]]);
		if (array_key_exists($keys[14], $arr)) $this->setOriginSchool($arr[$keys[14]]);
		if (array_key_exists($keys[15], $arr)) $this->setEducationalDependency($arr[$keys[15]]);
	}

	/**
	 * Build a Criteria object containing the values of all modified columns in this object.
	 *
	 * @return     Criteria The Criteria object containing all modified values.
	 */
	public function buildCriteria()
	{
		$criteria = new Criteria(StudentPeer::DATABASE_NAME);

		if ($this->isColumnModified(StudentPeer::ID)) $criteria->add(StudentPeer::ID, $this->id);
		if ($this->isColumnModified(StudentPeer::GLOBAL_FILE_NUMBER)) $criteria->add(StudentPeer::GLOBAL_FILE_NUMBER, $this->global_file_number);
		if ($this->isColumnModified(StudentPeer::ORDER_OF_MERIT)) $criteria->add(StudentPeer::ORDER_OF_MERIT, $this->order_of_merit);
		if ($this->isColumnModified(StudentPeer::YEAR_INCOME)) $criteria->add(StudentPeer::YEAR_INCOME, $this->year_income);
		if ($this->isColumnModified(StudentPeer::NATIONALITY)) $criteria->add(StudentPeer::NATIONALITY, $this->nationality);
		if ($this->isColumnModified(StudentPeer::FOLIO_NUMBER)) $criteria->add(StudentPeer::FOLIO_NUMBER, $this->folio_number);
		if ($this->isColumnModified(StudentPeer::PERSON_ID)) $criteria->add(StudentPeer::PERSON_ID, $this->person_id);
		if ($this->isColumnModified(StudentPeer::OCCUPATION_ID)) $criteria->add(StudentPeer::OCCUPATION_ID, $this->occupation_id);
		if ($this->isColumnModified(StudentPeer::BUSY_STARTS_AT)) $criteria->add(StudentPeer::BUSY_STARTS_AT, $this->busy_starts_at);
		if ($this->isColumnModified(StudentPeer::BUSY_ENDS_AT)) $criteria->add(StudentPeer::BUSY_ENDS_AT, $this->busy_ends_at);
		if ($this->isColumnModified(StudentPeer::BLOOD_GROUP)) $criteria->add(StudentPeer::BLOOD_GROUP, $this->blood_group);
		if ($this->isColumnModified(StudentPeer::BLOOD_FACTOR)) $criteria->add(StudentPeer::BLOOD_FACTOR, $this->blood_factor);
		if ($this->isColumnModified(StudentPeer::EMERGENCY_INFORMATION)) $criteria->add(StudentPeer::EMERGENCY_INFORMATION, $this->emergency_information);
		if ($this->isColumnModified(StudentPeer::HEALTH_COVERAGE_ID)) $criteria->add(StudentPeer::HEALTH_COVERAGE_ID, $this->health_coverage_id);
		if ($this->isColumnModified(StudentPeer::ORIGIN_SCHOOL)) $criteria->add(StudentPeer::ORIGIN_SCHOOL, $this->origin_school);
		if ($this->isColumnModified(StudentPeer::EDUCATIONAL_DEPENDENCY)) $criteria->add(StudentPeer::EDUCATIONAL_DEPENDENCY, $this->educational_dependency);

		return $criteria;
	}

	/**
	 * Builds a Criteria object containing the primary key for this object.
	 *
	 * Unlike buildCriteria() this method includes the primary key values regardless
	 * of whether or not they have been modified.
	 *
	 * @return     Criteria The Criteria object containing value(s) for primary key(s).
	 */
	public function buildPkeyCriteria()
	{
		$criteria = new Criteria(StudentPeer::DATABASE_NAME);

		$criteria->add(StudentPeer::ID, $this->id);

		return $criteria;
	}

	/**
	 * Returns the primary key for this object (row).
	 * @return     int
	 */
	public function getPrimaryKey()
	{
		return $this->getId();
	}

	/**
	 * Generic method to set the primary key (id column).
	 *
	 * @param      int $key Primary key.
	 * @return     void
	 */
	public function setPrimaryKey($key)
	{
		$this->setId($key);
	}

	/**
	 * Sets contents of passed object to values from current object.
	 *
	 * If desired, this method can also make copies of all associated (fkey referrers)
	 * objects.
	 *
	 * @param      object $copyObj An object of Student (or compatible) type.
	 * @param      boolean $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
	 * @throws     PropelException
	 */
	public function copyInto($copyObj, $deepCopy = false)
	{

		$copyObj->setGlobalFileNumber($this->global_file_number);

		$copyObj->setOrderOfMerit($this->order_of_merit);

		$copyObj->setYearIncome($this->year_income);

		$copyObj->setNationality($this->nationality);

		$copyObj->setFolioNumber($this->folio_number);

		$copyObj->setPersonId($this->person_id);

		$copyObj->setOccupationId($this->occupation_id);

		$copyObj->setBusyStartsAt($this->busy_starts_at);

		$copyObj->setBusyEndsAt($this->busy_ends_at);

		$copyObj->setBloodGroup($this->blood_group);

		$copyObj->setBloodFactor($this->blood_factor);

		$copyObj->setEmergencyInformation($this->emergency_information);

		$copyObj->setHealthCoverageId($this->health_coverage_id);

		$copyObj->setOriginSchool($this->origin_school);

		$copyObj->setEducationalDependency($this->educational_dependency);


		if ($deepCopy) {
			// important: temporarily setNew(false) because this affects the behavior of
			// the getter/setter methods for fkey referrer objects.
			$copyObj->setNew(false);

			foreach ($this->getStudentCareerSubjectAlloweds() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentCareerSubjectAllowed($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCourseSubjectStudents() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCourseSubjectStudent($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStudentApprovedCareerSubjects() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentApprovedCareerSubject($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStudentApprovedCourseSubjects() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentApprovedCourseSubject($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStudentStudys() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentStudy($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStudentAttendances() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentAttendance($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStudentReincorporations() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentReincorporation($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStudentFrees() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentFree($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getPathwayStudents() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addPathwayStudent($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCourseSubjectStudentPathways() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCourseSubjectStudentPathway($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCareerStudents() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCareerStudent($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStudentCareerSchoolYears() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentCareerSchoolYear($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getSchoolYearStudents() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addSchoolYearStudent($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDivisionStudents() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDivisionStudent($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStudentDisciplinarySanctions() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentDisciplinarySanction($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getBrotherhoodsRelatedByStudentId() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addBrotherhoodRelatedByStudentId($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getBrotherhoodsRelatedByBrotherId() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addBrotherhoodRelatedByBrotherId($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStudentTags() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentTag($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStudentTutors() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStudentTutor($relObj->copy($deepCopy));
				}
			}

		} // if ($deepCopy)


		$copyObj->setNew(true);

		$copyObj->setId(NULL); // this is a auto-increment column, so set to default value

	}

	/**
	 * Makes a copy of this object that will be inserted as a new row in table when saved.
	 * It creates a new object filling in the simple attributes, but skipping any primary
	 * keys that are defined for the table.
	 *
	 * If desired, this method can also make copies of all associated (fkey referrers)
	 * objects.
	 *
	 * @param      boolean $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
	 * @return     Student Clone of current object.
	 * @throws     PropelException
	 */
	public function copy($deepCopy = false)
	{
		// we use get_class(), because this might be a subclass
		$clazz = get_class($this);
		$copyObj = new $clazz();
		$this->copyInto($copyObj, $deepCopy);
		return $copyObj;
	}

	/**
	 * Returns a peer instance associated with this om.
	 *
	 * Since Peer classes are not to have any instance attributes, this method returns the
	 * same instance for all member of this class. The method could therefore
	 * be static, but this would prevent one from overriding the behavior.
	 *
	 * @return     StudentPeer
	 */
	public function getPeer()
	{
		if (self::$peer === null) {
			self::$peer = new StudentPeer();
		}
		return self::$peer;
	}

	/**
	 * Declares an association between this object and a Person object.
	 *
	 * @param      Person $v
	 * @return     Student The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setPerson(Person $v = null)
	{
		if ($v === null) {
			$this->setPersonId(NULL);
		} else {
			$this->setPersonId($v->getId());
		}

		$this->aPerson = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the Person object, it will not be re-added.
		if ($v !== null) {
			$v->addStudent($this);
		}

		return $this;
	}


	/**
	 * Get the associated Person object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     Person The associated Person object.
	 * @throws     PropelException
	 */
	public function getPerson(PropelPDO $con = null)
	{
		if ($this->aPerson === null && ($this->person_id !== null)) {
			$c = new Criteria(PersonPeer::DATABASE_NAME);
			$c->add(PersonPeer::ID, $this->person_id);
			$this->aPerson = PersonPeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aPerson->addStudents($this);
			 */
		}
		return $this->aPerson;
	}

	/**
	 * Declares an association between this object and a Occupation object.
	 *
	 * @param      Occupation $v
	 * @return     Student The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setOccupation(Occupation $v = null)
	{
		if ($v === null) {
			$this->setOccupationId(0);
		} else {
			$this->setOccupationId($v->getId());
		}

		$this->aOccupation = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the Occupation object, it will not be re-added.
		if ($v !== null) {
			$v->addStudent($this);
		}

		return $this;
	}


	/**
	 * Get the associated Occupation object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     Occupation The associated Occupation object.
	 * @throws     PropelException
	 */
	public function getOccupation(PropelPDO $con = null)
	{
		if ($this->aOccupation === null && ($this->occupation_id !== null)) {
			$c = new Criteria(OccupationPeer::DATABASE_NAME);
			$c->add(OccupationPeer::ID, $this->occupation_id);
			$this->aOccupation = OccupationPeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aOccupation->addStudents($this);
			 */
		}
		return $this->aOccupation;
	}

	/**
	 * Declares an association between this object and a HealthCoverage object.
	 *
	 * @param      HealthCoverage $v
	 * @return     Student The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setHealthCoverage(HealthCoverage $v = null)
	{
		if ($v === null) {
			$this->setHealthCoverageId(0);
		} else {
			$this->setHealthCoverageId($v->getId());
		}

		$this->aHealthCoverage = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the HealthCoverage object, it will not be re-added.
		if ($v !== null) {
			$v->addStudent($this);
		}

		return $this;
	}


	/**
	 * Get the associated HealthCoverage object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     HealthCoverage The associated HealthCoverage object.
	 * @throws     PropelException
	 */
	public function getHealthCoverage(PropelPDO $con = null)
	{
		if ($this->aHealthCoverage === null && ($this->health_coverage_id !== null)) {
			$c = new Criteria(HealthCoveragePeer::DATABASE_NAME);
			$c->add(HealthCoveragePeer::ID, $this->health_coverage_id);
			$this->aHealthCoverage = HealthCoveragePeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aHealthCoverage->addStudents($this);
			 */
		}
		return $this->aHealthCoverage;
	}

	/**
	 * Clears out the collStudentCareerSubjectAlloweds collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentCareerSubjectAlloweds()
	 */
	public function clearStudentCareerSubjectAlloweds()
	{
		$this->collStudentCareerSubjectAlloweds = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentCareerSubjectAlloweds collection (array).
	 *
	 * By default this just sets the collStudentCareerSubjectAlloweds collection to an empty array (like clearcollStudentCareerSubjectAlloweds());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentCareerSubjectAlloweds()
	{
		$this->collStudentCareerSubjectAlloweds = array();
	}

	/**
	 * Gets an array of StudentCareerSubjectAllowed objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentCareerSubjectAlloweds from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentCareerSubjectAllowed[]
	 * @throws     PropelException
	 */
	public function getStudentCareerSubjectAlloweds($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentCareerSubjectAlloweds === null) {
			if ($this->isNew()) {
			   $this->collStudentCareerSubjectAlloweds = array();
			} else {

				$criteria->add(StudentCareerSubjectAllowedPeer::STUDENT_ID, $this->id);

				StudentCareerSubjectAllowedPeer::addSelectColumns($criteria);
				$this->collStudentCareerSubjectAlloweds = StudentCareerSubjectAllowedPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentCareerSubjectAllowedPeer::STUDENT_ID, $this->id);

				StudentCareerSubjectAllowedPeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentCareerSubjectAllowedCriteria) || !$this->lastStudentCareerSubjectAllowedCriteria->equals($criteria)) {
					$this->collStudentCareerSubjectAlloweds = StudentCareerSubjectAllowedPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentCareerSubjectAllowedCriteria = $criteria;
		return $this->collStudentCareerSubjectAlloweds;
	}

	/**
	 * Returns the number of related StudentCareerSubjectAllowed objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentCareerSubjectAllowed objects.
	 * @throws     PropelException
	 */
	public function countStudentCareerSubjectAlloweds(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentCareerSubjectAlloweds === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentCareerSubjectAllowedPeer::STUDENT_ID, $this->id);

				$count = StudentCareerSubjectAllowedPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentCareerSubjectAllowedPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentCareerSubjectAllowedCriteria) || !$this->lastStudentCareerSubjectAllowedCriteria->equals($criteria)) {
					$count = StudentCareerSubjectAllowedPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentCareerSubjectAlloweds);
				}
			} else {
				$count = count($this->collStudentCareerSubjectAlloweds);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentCareerSubjectAllowed object to this object
	 * through the StudentCareerSubjectAllowed foreign key attribute.
	 *
	 * @param      StudentCareerSubjectAllowed $l StudentCareerSubjectAllowed
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentCareerSubjectAllowed(StudentCareerSubjectAllowed $l)
	{
		if ($this->collStudentCareerSubjectAlloweds === null) {
			$this->initStudentCareerSubjectAlloweds();
		}
		if (!in_array($l, $this->collStudentCareerSubjectAlloweds, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentCareerSubjectAlloweds, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentCareerSubjectAlloweds from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentCareerSubjectAllowedsJoinCareerSubject($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentCareerSubjectAlloweds === null) {
			if ($this->isNew()) {
				$this->collStudentCareerSubjectAlloweds = array();
			} else {

				$criteria->add(StudentCareerSubjectAllowedPeer::STUDENT_ID, $this->id);

				$this->collStudentCareerSubjectAlloweds = StudentCareerSubjectAllowedPeer::doSelectJoinCareerSubject($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentCareerSubjectAllowedPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentCareerSubjectAllowedCriteria) || !$this->lastStudentCareerSubjectAllowedCriteria->equals($criteria)) {
				$this->collStudentCareerSubjectAlloweds = StudentCareerSubjectAllowedPeer::doSelectJoinCareerSubject($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentCareerSubjectAllowedCriteria = $criteria;

		return $this->collStudentCareerSubjectAlloweds;
	}

	/**
	 * Clears out the collCourseSubjectStudents collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCourseSubjectStudents()
	 */
	public function clearCourseSubjectStudents()
	{
		$this->collCourseSubjectStudents = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCourseSubjectStudents collection (array).
	 *
	 * By default this just sets the collCourseSubjectStudents collection to an empty array (like clearcollCourseSubjectStudents());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCourseSubjectStudents()
	{
		$this->collCourseSubjectStudents = array();
	}

	/**
	 * Gets an array of CourseSubjectStudent objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related CourseSubjectStudents from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array CourseSubjectStudent[]
	 * @throws     PropelException
	 */
	public function getCourseSubjectStudents($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCourseSubjectStudents === null) {
			if ($this->isNew()) {
			   $this->collCourseSubjectStudents = array();
			} else {

				$criteria->add(CourseSubjectStudentPeer::STUDENT_ID, $this->id);

				CourseSubjectStudentPeer::addSelectColumns($criteria);
				$this->collCourseSubjectStudents = CourseSubjectStudentPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CourseSubjectStudentPeer::STUDENT_ID, $this->id);

				CourseSubjectStudentPeer::addSelectColumns($criteria);
				if (!isset($this->lastCourseSubjectStudentCriteria) || !$this->lastCourseSubjectStudentCriteria->equals($criteria)) {
					$this->collCourseSubjectStudents = CourseSubjectStudentPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCourseSubjectStudentCriteria = $criteria;
		return $this->collCourseSubjectStudents;
	}

	/**
	 * Returns the number of related CourseSubjectStudent objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related CourseSubjectStudent objects.
	 * @throws     PropelException
	 */
	public function countCourseSubjectStudents(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCourseSubjectStudents === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CourseSubjectStudentPeer::STUDENT_ID, $this->id);

				$count = CourseSubjectStudentPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CourseSubjectStudentPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastCourseSubjectStudentCriteria) || !$this->lastCourseSubjectStudentCriteria->equals($criteria)) {
					$count = CourseSubjectStudentPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collCourseSubjectStudents);
				}
			} else {
				$count = count($this->collCourseSubjectStudents);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a CourseSubjectStudent object to this object
	 * through the CourseSubjectStudent foreign key attribute.
	 *
	 * @param      CourseSubjectStudent $l CourseSubjectStudent
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCourseSubjectStudent(CourseSubjectStudent $l)
	{
		if ($this->collCourseSubjectStudents === null) {
			$this->initCourseSubjectStudents();
		}
		if (!in_array($l, $this->collCourseSubjectStudents, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCourseSubjectStudents, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related CourseSubjectStudents from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getCourseSubjectStudentsJoinCourseSubject($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCourseSubjectStudents === null) {
			if ($this->isNew()) {
				$this->collCourseSubjectStudents = array();
			} else {

				$criteria->add(CourseSubjectStudentPeer::STUDENT_ID, $this->id);

				$this->collCourseSubjectStudents = CourseSubjectStudentPeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CourseSubjectStudentPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastCourseSubjectStudentCriteria) || !$this->lastCourseSubjectStudentCriteria->equals($criteria)) {
				$this->collCourseSubjectStudents = CourseSubjectStudentPeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		}
		$this->lastCourseSubjectStudentCriteria = $criteria;

		return $this->collCourseSubjectStudents;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related CourseSubjectStudents from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getCourseSubjectStudentsJoinStudentApprovedCourseSubject($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCourseSubjectStudents === null) {
			if ($this->isNew()) {
				$this->collCourseSubjectStudents = array();
			} else {

				$criteria->add(CourseSubjectStudentPeer::STUDENT_ID, $this->id);

				$this->collCourseSubjectStudents = CourseSubjectStudentPeer::doSelectJoinStudentApprovedCourseSubject($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CourseSubjectStudentPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastCourseSubjectStudentCriteria) || !$this->lastCourseSubjectStudentCriteria->equals($criteria)) {
				$this->collCourseSubjectStudents = CourseSubjectStudentPeer::doSelectJoinStudentApprovedCourseSubject($criteria, $con, $join_behavior);
			}
		}
		$this->lastCourseSubjectStudentCriteria = $criteria;

		return $this->collCourseSubjectStudents;
	}

	/**
	 * Clears out the collStudentApprovedCareerSubjects collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentApprovedCareerSubjects()
	 */
	public function clearStudentApprovedCareerSubjects()
	{
		$this->collStudentApprovedCareerSubjects = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentApprovedCareerSubjects collection (array).
	 *
	 * By default this just sets the collStudentApprovedCareerSubjects collection to an empty array (like clearcollStudentApprovedCareerSubjects());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentApprovedCareerSubjects()
	{
		$this->collStudentApprovedCareerSubjects = array();
	}

	/**
	 * Gets an array of StudentApprovedCareerSubject objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentApprovedCareerSubjects from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentApprovedCareerSubject[]
	 * @throws     PropelException
	 */
	public function getStudentApprovedCareerSubjects($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentApprovedCareerSubjects === null) {
			if ($this->isNew()) {
			   $this->collStudentApprovedCareerSubjects = array();
			} else {

				$criteria->add(StudentApprovedCareerSubjectPeer::STUDENT_ID, $this->id);

				StudentApprovedCareerSubjectPeer::addSelectColumns($criteria);
				$this->collStudentApprovedCareerSubjects = StudentApprovedCareerSubjectPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentApprovedCareerSubjectPeer::STUDENT_ID, $this->id);

				StudentApprovedCareerSubjectPeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentApprovedCareerSubjectCriteria) || !$this->lastStudentApprovedCareerSubjectCriteria->equals($criteria)) {
					$this->collStudentApprovedCareerSubjects = StudentApprovedCareerSubjectPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentApprovedCareerSubjectCriteria = $criteria;
		return $this->collStudentApprovedCareerSubjects;
	}

	/**
	 * Returns the number of related StudentApprovedCareerSubject objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentApprovedCareerSubject objects.
	 * @throws     PropelException
	 */
	public function countStudentApprovedCareerSubjects(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentApprovedCareerSubjects === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentApprovedCareerSubjectPeer::STUDENT_ID, $this->id);

				$count = StudentApprovedCareerSubjectPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentApprovedCareerSubjectPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentApprovedCareerSubjectCriteria) || !$this->lastStudentApprovedCareerSubjectCriteria->equals($criteria)) {
					$count = StudentApprovedCareerSubjectPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentApprovedCareerSubjects);
				}
			} else {
				$count = count($this->collStudentApprovedCareerSubjects);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentApprovedCareerSubject object to this object
	 * through the StudentApprovedCareerSubject foreign key attribute.
	 *
	 * @param      StudentApprovedCareerSubject $l StudentApprovedCareerSubject
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentApprovedCareerSubject(StudentApprovedCareerSubject $l)
	{
		if ($this->collStudentApprovedCareerSubjects === null) {
			$this->initStudentApprovedCareerSubjects();
		}
		if (!in_array($l, $this->collStudentApprovedCareerSubjects, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentApprovedCareerSubjects, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentApprovedCareerSubjects from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentApprovedCareerSubjectsJoinCareerSubject($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentApprovedCareerSubjects === null) {
			if ($this->isNew()) {
				$this->collStudentApprovedCareerSubjects = array();
			} else {

				$criteria->add(StudentApprovedCareerSubjectPeer::STUDENT_ID, $this->id);

				$this->collStudentApprovedCareerSubjects = StudentApprovedCareerSubjectPeer::doSelectJoinCareerSubject($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentApprovedCareerSubjectPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentApprovedCareerSubjectCriteria) || !$this->lastStudentApprovedCareerSubjectCriteria->equals($criteria)) {
				$this->collStudentApprovedCareerSubjects = StudentApprovedCareerSubjectPeer::doSelectJoinCareerSubject($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentApprovedCareerSubjectCriteria = $criteria;

		return $this->collStudentApprovedCareerSubjects;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentApprovedCareerSubjects from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentApprovedCareerSubjectsJoinSchoolYear($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentApprovedCareerSubjects === null) {
			if ($this->isNew()) {
				$this->collStudentApprovedCareerSubjects = array();
			} else {

				$criteria->add(StudentApprovedCareerSubjectPeer::STUDENT_ID, $this->id);

				$this->collStudentApprovedCareerSubjects = StudentApprovedCareerSubjectPeer::doSelectJoinSchoolYear($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentApprovedCareerSubjectPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentApprovedCareerSubjectCriteria) || !$this->lastStudentApprovedCareerSubjectCriteria->equals($criteria)) {
				$this->collStudentApprovedCareerSubjects = StudentApprovedCareerSubjectPeer::doSelectJoinSchoolYear($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentApprovedCareerSubjectCriteria = $criteria;

		return $this->collStudentApprovedCareerSubjects;
	}

	/**
	 * Clears out the collStudentApprovedCourseSubjects collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentApprovedCourseSubjects()
	 */
	public function clearStudentApprovedCourseSubjects()
	{
		$this->collStudentApprovedCourseSubjects = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentApprovedCourseSubjects collection (array).
	 *
	 * By default this just sets the collStudentApprovedCourseSubjects collection to an empty array (like clearcollStudentApprovedCourseSubjects());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentApprovedCourseSubjects()
	{
		$this->collStudentApprovedCourseSubjects = array();
	}

	/**
	 * Gets an array of StudentApprovedCourseSubject objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentApprovedCourseSubjects from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentApprovedCourseSubject[]
	 * @throws     PropelException
	 */
	public function getStudentApprovedCourseSubjects($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentApprovedCourseSubjects === null) {
			if ($this->isNew()) {
			   $this->collStudentApprovedCourseSubjects = array();
			} else {

				$criteria->add(StudentApprovedCourseSubjectPeer::STUDENT_ID, $this->id);

				StudentApprovedCourseSubjectPeer::addSelectColumns($criteria);
				$this->collStudentApprovedCourseSubjects = StudentApprovedCourseSubjectPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentApprovedCourseSubjectPeer::STUDENT_ID, $this->id);

				StudentApprovedCourseSubjectPeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentApprovedCourseSubjectCriteria) || !$this->lastStudentApprovedCourseSubjectCriteria->equals($criteria)) {
					$this->collStudentApprovedCourseSubjects = StudentApprovedCourseSubjectPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentApprovedCourseSubjectCriteria = $criteria;
		return $this->collStudentApprovedCourseSubjects;
	}

	/**
	 * Returns the number of related StudentApprovedCourseSubject objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentApprovedCourseSubject objects.
	 * @throws     PropelException
	 */
	public function countStudentApprovedCourseSubjects(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentApprovedCourseSubjects === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentApprovedCourseSubjectPeer::STUDENT_ID, $this->id);

				$count = StudentApprovedCourseSubjectPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentApprovedCourseSubjectPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentApprovedCourseSubjectCriteria) || !$this->lastStudentApprovedCourseSubjectCriteria->equals($criteria)) {
					$count = StudentApprovedCourseSubjectPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentApprovedCourseSubjects);
				}
			} else {
				$count = count($this->collStudentApprovedCourseSubjects);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentApprovedCourseSubject object to this object
	 * through the StudentApprovedCourseSubject foreign key attribute.
	 *
	 * @param      StudentApprovedCourseSubject $l StudentApprovedCourseSubject
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentApprovedCourseSubject(StudentApprovedCourseSubject $l)
	{
		if ($this->collStudentApprovedCourseSubjects === null) {
			$this->initStudentApprovedCourseSubjects();
		}
		if (!in_array($l, $this->collStudentApprovedCourseSubjects, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentApprovedCourseSubjects, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentApprovedCourseSubjects from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentApprovedCourseSubjectsJoinCourseSubject($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentApprovedCourseSubjects === null) {
			if ($this->isNew()) {
				$this->collStudentApprovedCourseSubjects = array();
			} else {

				$criteria->add(StudentApprovedCourseSubjectPeer::STUDENT_ID, $this->id);

				$this->collStudentApprovedCourseSubjects = StudentApprovedCourseSubjectPeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentApprovedCourseSubjectPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentApprovedCourseSubjectCriteria) || !$this->lastStudentApprovedCourseSubjectCriteria->equals($criteria)) {
				$this->collStudentApprovedCourseSubjects = StudentApprovedCourseSubjectPeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentApprovedCourseSubjectCriteria = $criteria;

		return $this->collStudentApprovedCourseSubjects;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentApprovedCourseSubjects from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentApprovedCourseSubjectsJoinSchoolYear($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentApprovedCourseSubjects === null) {
			if ($this->isNew()) {
				$this->collStudentApprovedCourseSubjects = array();
			} else {

				$criteria->add(StudentApprovedCourseSubjectPeer::STUDENT_ID, $this->id);

				$this->collStudentApprovedCourseSubjects = StudentApprovedCourseSubjectPeer::doSelectJoinSchoolYear($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentApprovedCourseSubjectPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentApprovedCourseSubjectCriteria) || !$this->lastStudentApprovedCourseSubjectCriteria->equals($criteria)) {
				$this->collStudentApprovedCourseSubjects = StudentApprovedCourseSubjectPeer::doSelectJoinSchoolYear($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentApprovedCourseSubjectCriteria = $criteria;

		return $this->collStudentApprovedCourseSubjects;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentApprovedCourseSubjects from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentApprovedCourseSubjectsJoinStudentApprovedCareerSubject($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentApprovedCourseSubjects === null) {
			if ($this->isNew()) {
				$this->collStudentApprovedCourseSubjects = array();
			} else {

				$criteria->add(StudentApprovedCourseSubjectPeer::STUDENT_ID, $this->id);

				$this->collStudentApprovedCourseSubjects = StudentApprovedCourseSubjectPeer::doSelectJoinStudentApprovedCareerSubject($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentApprovedCourseSubjectPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentApprovedCourseSubjectCriteria) || !$this->lastStudentApprovedCourseSubjectCriteria->equals($criteria)) {
				$this->collStudentApprovedCourseSubjects = StudentApprovedCourseSubjectPeer::doSelectJoinStudentApprovedCareerSubject($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentApprovedCourseSubjectCriteria = $criteria;

		return $this->collStudentApprovedCourseSubjects;
	}

	/**
	 * Clears out the collStudentStudys collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentStudys()
	 */
	public function clearStudentStudys()
	{
		$this->collStudentStudys = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentStudys collection (array).
	 *
	 * By default this just sets the collStudentStudys collection to an empty array (like clearcollStudentStudys());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentStudys()
	{
		$this->collStudentStudys = array();
	}

	/**
	 * Gets an array of StudentStudy objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentStudys from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentStudy[]
	 * @throws     PropelException
	 */
	public function getStudentStudys($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentStudys === null) {
			if ($this->isNew()) {
			   $this->collStudentStudys = array();
			} else {

				$criteria->add(StudentStudyPeer::STUDENT_ID, $this->id);

				StudentStudyPeer::addSelectColumns($criteria);
				$this->collStudentStudys = StudentStudyPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentStudyPeer::STUDENT_ID, $this->id);

				StudentStudyPeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentStudyCriteria) || !$this->lastStudentStudyCriteria->equals($criteria)) {
					$this->collStudentStudys = StudentStudyPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentStudyCriteria = $criteria;
		return $this->collStudentStudys;
	}

	/**
	 * Returns the number of related StudentStudy objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentStudy objects.
	 * @throws     PropelException
	 */
	public function countStudentStudys(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentStudys === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentStudyPeer::STUDENT_ID, $this->id);

				$count = StudentStudyPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentStudyPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentStudyCriteria) || !$this->lastStudentStudyCriteria->equals($criteria)) {
					$count = StudentStudyPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentStudys);
				}
			} else {
				$count = count($this->collStudentStudys);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentStudy object to this object
	 * through the StudentStudy foreign key attribute.
	 *
	 * @param      StudentStudy $l StudentStudy
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentStudy(StudentStudy $l)
	{
		if ($this->collStudentStudys === null) {
			$this->initStudentStudys();
		}
		if (!in_array($l, $this->collStudentStudys, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentStudys, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentStudys from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentStudysJoinStudy($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentStudys === null) {
			if ($this->isNew()) {
				$this->collStudentStudys = array();
			} else {

				$criteria->add(StudentStudyPeer::STUDENT_ID, $this->id);

				$this->collStudentStudys = StudentStudyPeer::doSelectJoinStudy($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentStudyPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentStudyCriteria) || !$this->lastStudentStudyCriteria->equals($criteria)) {
				$this->collStudentStudys = StudentStudyPeer::doSelectJoinStudy($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentStudyCriteria = $criteria;

		return $this->collStudentStudys;
	}

	/**
	 * Clears out the collStudentAttendances collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentAttendances()
	 */
	public function clearStudentAttendances()
	{
		$this->collStudentAttendances = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentAttendances collection (array).
	 *
	 * By default this just sets the collStudentAttendances collection to an empty array (like clearcollStudentAttendances());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentAttendances()
	{
		$this->collStudentAttendances = array();
	}

	/**
	 * Gets an array of StudentAttendance objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentAttendances from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentAttendance[]
	 * @throws     PropelException
	 */
	public function getStudentAttendances($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentAttendances === null) {
			if ($this->isNew()) {
			   $this->collStudentAttendances = array();
			} else {

				$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

				StudentAttendancePeer::addSelectColumns($criteria);
				$this->collStudentAttendances = StudentAttendancePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

				StudentAttendancePeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentAttendanceCriteria) || !$this->lastStudentAttendanceCriteria->equals($criteria)) {
					$this->collStudentAttendances = StudentAttendancePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentAttendanceCriteria = $criteria;
		return $this->collStudentAttendances;
	}

	/**
	 * Returns the number of related StudentAttendance objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentAttendance objects.
	 * @throws     PropelException
	 */
	public function countStudentAttendances(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentAttendances === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

				$count = StudentAttendancePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentAttendanceCriteria) || !$this->lastStudentAttendanceCriteria->equals($criteria)) {
					$count = StudentAttendancePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentAttendances);
				}
			} else {
				$count = count($this->collStudentAttendances);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentAttendance object to this object
	 * through the StudentAttendance foreign key attribute.
	 *
	 * @param      StudentAttendance $l StudentAttendance
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentAttendance(StudentAttendance $l)
	{
		if ($this->collStudentAttendances === null) {
			$this->initStudentAttendances();
		}
		if (!in_array($l, $this->collStudentAttendances, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentAttendances, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentAttendances from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentAttendancesJoinCareerSchoolYear($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentAttendances === null) {
			if ($this->isNew()) {
				$this->collStudentAttendances = array();
			} else {

				$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

				$this->collStudentAttendances = StudentAttendancePeer::doSelectJoinCareerSchoolYear($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentAttendanceCriteria) || !$this->lastStudentAttendanceCriteria->equals($criteria)) {
				$this->collStudentAttendances = StudentAttendancePeer::doSelectJoinCareerSchoolYear($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentAttendanceCriteria = $criteria;

		return $this->collStudentAttendances;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentAttendances from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentAttendancesJoinAbsenceType($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentAttendances === null) {
			if ($this->isNew()) {
				$this->collStudentAttendances = array();
			} else {

				$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

				$this->collStudentAttendances = StudentAttendancePeer::doSelectJoinAbsenceType($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentAttendanceCriteria) || !$this->lastStudentAttendanceCriteria->equals($criteria)) {
				$this->collStudentAttendances = StudentAttendancePeer::doSelectJoinAbsenceType($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentAttendanceCriteria = $criteria;

		return $this->collStudentAttendances;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentAttendances from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentAttendancesJoinCourseSubject($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentAttendances === null) {
			if ($this->isNew()) {
				$this->collStudentAttendances = array();
			} else {

				$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

				$this->collStudentAttendances = StudentAttendancePeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentAttendanceCriteria) || !$this->lastStudentAttendanceCriteria->equals($criteria)) {
				$this->collStudentAttendances = StudentAttendancePeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentAttendanceCriteria = $criteria;

		return $this->collStudentAttendances;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentAttendances from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentAttendancesJoinStudentAttendanceJustification($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentAttendances === null) {
			if ($this->isNew()) {
				$this->collStudentAttendances = array();
			} else {

				$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

				$this->collStudentAttendances = StudentAttendancePeer::doSelectJoinStudentAttendanceJustification($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentAttendancePeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentAttendanceCriteria) || !$this->lastStudentAttendanceCriteria->equals($criteria)) {
				$this->collStudentAttendances = StudentAttendancePeer::doSelectJoinStudentAttendanceJustification($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentAttendanceCriteria = $criteria;

		return $this->collStudentAttendances;
	}

	/**
	 * Clears out the collStudentReincorporations collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentReincorporations()
	 */
	public function clearStudentReincorporations()
	{
		$this->collStudentReincorporations = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentReincorporations collection (array).
	 *
	 * By default this just sets the collStudentReincorporations collection to an empty array (like clearcollStudentReincorporations());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentReincorporations()
	{
		$this->collStudentReincorporations = array();
	}

	/**
	 * Gets an array of StudentReincorporation objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentReincorporations from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentReincorporation[]
	 * @throws     PropelException
	 */
	public function getStudentReincorporations($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentReincorporations === null) {
			if ($this->isNew()) {
			   $this->collStudentReincorporations = array();
			} else {

				$criteria->add(StudentReincorporationPeer::STUDENT_ID, $this->id);

				StudentReincorporationPeer::addSelectColumns($criteria);
				$this->collStudentReincorporations = StudentReincorporationPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentReincorporationPeer::STUDENT_ID, $this->id);

				StudentReincorporationPeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentReincorporationCriteria) || !$this->lastStudentReincorporationCriteria->equals($criteria)) {
					$this->collStudentReincorporations = StudentReincorporationPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentReincorporationCriteria = $criteria;
		return $this->collStudentReincorporations;
	}

	/**
	 * Returns the number of related StudentReincorporation objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentReincorporation objects.
	 * @throws     PropelException
	 */
	public function countStudentReincorporations(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentReincorporations === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentReincorporationPeer::STUDENT_ID, $this->id);

				$count = StudentReincorporationPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentReincorporationPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentReincorporationCriteria) || !$this->lastStudentReincorporationCriteria->equals($criteria)) {
					$count = StudentReincorporationPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentReincorporations);
				}
			} else {
				$count = count($this->collStudentReincorporations);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentReincorporation object to this object
	 * through the StudentReincorporation foreign key attribute.
	 *
	 * @param      StudentReincorporation $l StudentReincorporation
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentReincorporation(StudentReincorporation $l)
	{
		if ($this->collStudentReincorporations === null) {
			$this->initStudentReincorporations();
		}
		if (!in_array($l, $this->collStudentReincorporations, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentReincorporations, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentReincorporations from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentReincorporationsJoinCareerSchoolYearPeriod($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentReincorporations === null) {
			if ($this->isNew()) {
				$this->collStudentReincorporations = array();
			} else {

				$criteria->add(StudentReincorporationPeer::STUDENT_ID, $this->id);

				$this->collStudentReincorporations = StudentReincorporationPeer::doSelectJoinCareerSchoolYearPeriod($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentReincorporationPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentReincorporationCriteria) || !$this->lastStudentReincorporationCriteria->equals($criteria)) {
				$this->collStudentReincorporations = StudentReincorporationPeer::doSelectJoinCareerSchoolYearPeriod($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentReincorporationCriteria = $criteria;

		return $this->collStudentReincorporations;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentReincorporations from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentReincorporationsJoinCourseSubject($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentReincorporations === null) {
			if ($this->isNew()) {
				$this->collStudentReincorporations = array();
			} else {

				$criteria->add(StudentReincorporationPeer::STUDENT_ID, $this->id);

				$this->collStudentReincorporations = StudentReincorporationPeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentReincorporationPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentReincorporationCriteria) || !$this->lastStudentReincorporationCriteria->equals($criteria)) {
				$this->collStudentReincorporations = StudentReincorporationPeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentReincorporationCriteria = $criteria;

		return $this->collStudentReincorporations;
	}

	/**
	 * Clears out the collStudentFrees collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentFrees()
	 */
	public function clearStudentFrees()
	{
		$this->collStudentFrees = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentFrees collection (array).
	 *
	 * By default this just sets the collStudentFrees collection to an empty array (like clearcollStudentFrees());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentFrees()
	{
		$this->collStudentFrees = array();
	}

	/**
	 * Gets an array of StudentFree objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentFrees from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentFree[]
	 * @throws     PropelException
	 */
	public function getStudentFrees($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentFrees === null) {
			if ($this->isNew()) {
			   $this->collStudentFrees = array();
			} else {

				$criteria->add(StudentFreePeer::STUDENT_ID, $this->id);

				StudentFreePeer::addSelectColumns($criteria);
				$this->collStudentFrees = StudentFreePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentFreePeer::STUDENT_ID, $this->id);

				StudentFreePeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentFreeCriteria) || !$this->lastStudentFreeCriteria->equals($criteria)) {
					$this->collStudentFrees = StudentFreePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentFreeCriteria = $criteria;
		return $this->collStudentFrees;
	}

	/**
	 * Returns the number of related StudentFree objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentFree objects.
	 * @throws     PropelException
	 */
	public function countStudentFrees(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentFrees === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentFreePeer::STUDENT_ID, $this->id);

				$count = StudentFreePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentFreePeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentFreeCriteria) || !$this->lastStudentFreeCriteria->equals($criteria)) {
					$count = StudentFreePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentFrees);
				}
			} else {
				$count = count($this->collStudentFrees);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentFree object to this object
	 * through the StudentFree foreign key attribute.
	 *
	 * @param      StudentFree $l StudentFree
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentFree(StudentFree $l)
	{
		if ($this->collStudentFrees === null) {
			$this->initStudentFrees();
		}
		if (!in_array($l, $this->collStudentFrees, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentFrees, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentFrees from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentFreesJoinCareerSchoolYearPeriod($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentFrees === null) {
			if ($this->isNew()) {
				$this->collStudentFrees = array();
			} else {

				$criteria->add(StudentFreePeer::STUDENT_ID, $this->id);

				$this->collStudentFrees = StudentFreePeer::doSelectJoinCareerSchoolYearPeriod($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentFreePeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentFreeCriteria) || !$this->lastStudentFreeCriteria->equals($criteria)) {
				$this->collStudentFrees = StudentFreePeer::doSelectJoinCareerSchoolYearPeriod($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentFreeCriteria = $criteria;

		return $this->collStudentFrees;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentFrees from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentFreesJoinCareerSchoolYear($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentFrees === null) {
			if ($this->isNew()) {
				$this->collStudentFrees = array();
			} else {

				$criteria->add(StudentFreePeer::STUDENT_ID, $this->id);

				$this->collStudentFrees = StudentFreePeer::doSelectJoinCareerSchoolYear($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentFreePeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentFreeCriteria) || !$this->lastStudentFreeCriteria->equals($criteria)) {
				$this->collStudentFrees = StudentFreePeer::doSelectJoinCareerSchoolYear($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentFreeCriteria = $criteria;

		return $this->collStudentFrees;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentFrees from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentFreesJoinCourseSubject($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentFrees === null) {
			if ($this->isNew()) {
				$this->collStudentFrees = array();
			} else {

				$criteria->add(StudentFreePeer::STUDENT_ID, $this->id);

				$this->collStudentFrees = StudentFreePeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentFreePeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentFreeCriteria) || !$this->lastStudentFreeCriteria->equals($criteria)) {
				$this->collStudentFrees = StudentFreePeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentFreeCriteria = $criteria;

		return $this->collStudentFrees;
	}

	/**
	 * Clears out the collPathwayStudents collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addPathwayStudents()
	 */
	public function clearPathwayStudents()
	{
		$this->collPathwayStudents = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collPathwayStudents collection (array).
	 *
	 * By default this just sets the collPathwayStudents collection to an empty array (like clearcollPathwayStudents());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initPathwayStudents()
	{
		$this->collPathwayStudents = array();
	}

	/**
	 * Gets an array of PathwayStudent objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related PathwayStudents from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array PathwayStudent[]
	 * @throws     PropelException
	 */
	public function getPathwayStudents($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPathwayStudents === null) {
			if ($this->isNew()) {
			   $this->collPathwayStudents = array();
			} else {

				$criteria->add(PathwayStudentPeer::STUDENT_ID, $this->id);

				PathwayStudentPeer::addSelectColumns($criteria);
				$this->collPathwayStudents = PathwayStudentPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(PathwayStudentPeer::STUDENT_ID, $this->id);

				PathwayStudentPeer::addSelectColumns($criteria);
				if (!isset($this->lastPathwayStudentCriteria) || !$this->lastPathwayStudentCriteria->equals($criteria)) {
					$this->collPathwayStudents = PathwayStudentPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastPathwayStudentCriteria = $criteria;
		return $this->collPathwayStudents;
	}

	/**
	 * Returns the number of related PathwayStudent objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related PathwayStudent objects.
	 * @throws     PropelException
	 */
	public function countPathwayStudents(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collPathwayStudents === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(PathwayStudentPeer::STUDENT_ID, $this->id);

				$count = PathwayStudentPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(PathwayStudentPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastPathwayStudentCriteria) || !$this->lastPathwayStudentCriteria->equals($criteria)) {
					$count = PathwayStudentPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collPathwayStudents);
				}
			} else {
				$count = count($this->collPathwayStudents);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a PathwayStudent object to this object
	 * through the PathwayStudent foreign key attribute.
	 *
	 * @param      PathwayStudent $l PathwayStudent
	 * @return     void
	 * @throws     PropelException
	 */
	public function addPathwayStudent(PathwayStudent $l)
	{
		if ($this->collPathwayStudents === null) {
			$this->initPathwayStudents();
		}
		if (!in_array($l, $this->collPathwayStudents, true)) { // only add it if the **same** object is not already associated
			array_push($this->collPathwayStudents, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related PathwayStudents from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getPathwayStudentsJoinPathway($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collPathwayStudents === null) {
			if ($this->isNew()) {
				$this->collPathwayStudents = array();
			} else {

				$criteria->add(PathwayStudentPeer::STUDENT_ID, $this->id);

				$this->collPathwayStudents = PathwayStudentPeer::doSelectJoinPathway($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(PathwayStudentPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastPathwayStudentCriteria) || !$this->lastPathwayStudentCriteria->equals($criteria)) {
				$this->collPathwayStudents = PathwayStudentPeer::doSelectJoinPathway($criteria, $con, $join_behavior);
			}
		}
		$this->lastPathwayStudentCriteria = $criteria;

		return $this->collPathwayStudents;
	}

	/**
	 * Clears out the collCourseSubjectStudentPathways collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCourseSubjectStudentPathways()
	 */
	public function clearCourseSubjectStudentPathways()
	{
		$this->collCourseSubjectStudentPathways = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCourseSubjectStudentPathways collection (array).
	 *
	 * By default this just sets the collCourseSubjectStudentPathways collection to an empty array (like clearcollCourseSubjectStudentPathways());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCourseSubjectStudentPathways()
	{
		$this->collCourseSubjectStudentPathways = array();
	}

	/**
	 * Gets an array of CourseSubjectStudentPathway objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related CourseSubjectStudentPathways from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array CourseSubjectStudentPathway[]
	 * @throws     PropelException
	 */
	public function getCourseSubjectStudentPathways($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCourseSubjectStudentPathways === null) {
			if ($this->isNew()) {
			   $this->collCourseSubjectStudentPathways = array();
			} else {

				$criteria->add(CourseSubjectStudentPathwayPeer::STUDENT_ID, $this->id);

				CourseSubjectStudentPathwayPeer::addSelectColumns($criteria);
				$this->collCourseSubjectStudentPathways = CourseSubjectStudentPathwayPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CourseSubjectStudentPathwayPeer::STUDENT_ID, $this->id);

				CourseSubjectStudentPathwayPeer::addSelectColumns($criteria);
				if (!isset($this->lastCourseSubjectStudentPathwayCriteria) || !$this->lastCourseSubjectStudentPathwayCriteria->equals($criteria)) {
					$this->collCourseSubjectStudentPathways = CourseSubjectStudentPathwayPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCourseSubjectStudentPathwayCriteria = $criteria;
		return $this->collCourseSubjectStudentPathways;
	}

	/**
	 * Returns the number of related CourseSubjectStudentPathway objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related CourseSubjectStudentPathway objects.
	 * @throws     PropelException
	 */
	public function countCourseSubjectStudentPathways(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCourseSubjectStudentPathways === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CourseSubjectStudentPathwayPeer::STUDENT_ID, $this->id);

				$count = CourseSubjectStudentPathwayPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CourseSubjectStudentPathwayPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastCourseSubjectStudentPathwayCriteria) || !$this->lastCourseSubjectStudentPathwayCriteria->equals($criteria)) {
					$count = CourseSubjectStudentPathwayPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collCourseSubjectStudentPathways);
				}
			} else {
				$count = count($this->collCourseSubjectStudentPathways);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a CourseSubjectStudentPathway object to this object
	 * through the CourseSubjectStudentPathway foreign key attribute.
	 *
	 * @param      CourseSubjectStudentPathway $l CourseSubjectStudentPathway
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCourseSubjectStudentPathway(CourseSubjectStudentPathway $l)
	{
		if ($this->collCourseSubjectStudentPathways === null) {
			$this->initCourseSubjectStudentPathways();
		}
		if (!in_array($l, $this->collCourseSubjectStudentPathways, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCourseSubjectStudentPathways, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related CourseSubjectStudentPathways from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getCourseSubjectStudentPathwaysJoinCourseSubject($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCourseSubjectStudentPathways === null) {
			if ($this->isNew()) {
				$this->collCourseSubjectStudentPathways = array();
			} else {

				$criteria->add(CourseSubjectStudentPathwayPeer::STUDENT_ID, $this->id);

				$this->collCourseSubjectStudentPathways = CourseSubjectStudentPathwayPeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CourseSubjectStudentPathwayPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastCourseSubjectStudentPathwayCriteria) || !$this->lastCourseSubjectStudentPathwayCriteria->equals($criteria)) {
				$this->collCourseSubjectStudentPathways = CourseSubjectStudentPathwayPeer::doSelectJoinCourseSubject($criteria, $con, $join_behavior);
			}
		}
		$this->lastCourseSubjectStudentPathwayCriteria = $criteria;

		return $this->collCourseSubjectStudentPathways;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related CourseSubjectStudentPathways from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getCourseSubjectStudentPathwaysJoinPathwayStudent($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCourseSubjectStudentPathways === null) {
			if ($this->isNew()) {
				$this->collCourseSubjectStudentPathways = array();
			} else {

				$criteria->add(CourseSubjectStudentPathwayPeer::STUDENT_ID, $this->id);

				$this->collCourseSubjectStudentPathways = CourseSubjectStudentPathwayPeer::doSelectJoinPathwayStudent($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CourseSubjectStudentPathwayPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastCourseSubjectStudentPathwayCriteria) || !$this->lastCourseSubjectStudentPathwayCriteria->equals($criteria)) {
				$this->collCourseSubjectStudentPathways = CourseSubjectStudentPathwayPeer::doSelectJoinPathwayStudent($criteria, $con, $join_behavior);
			}
		}
		$this->lastCourseSubjectStudentPathwayCriteria = $criteria;

		return $this->collCourseSubjectStudentPathways;
	}

	/**
	 * Clears out the collCareerStudents collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCareerStudents()
	 */
	public function clearCareerStudents()
	{
		$this->collCareerStudents = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCareerStudents collection (array).
	 *
	 * By default this just sets the collCareerStudents collection to an empty array (like clearcollCareerStudents());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCareerStudents()
	{
		$this->collCareerStudents = array();
	}

	/**
	 * Gets an array of CareerStudent objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related CareerStudents from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array CareerStudent[]
	 * @throws     PropelException
	 */
	public function getCareerStudents($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCareerStudents === null) {
			if ($this->isNew()) {
			   $this->collCareerStudents = array();
			} else {

				$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

				CareerStudentPeer::addSelectColumns($criteria);
				$this->collCareerStudents = CareerStudentPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

				CareerStudentPeer::addSelectColumns($criteria);
				if (!isset($this->lastCareerStudentCriteria) || !$this->lastCareerStudentCriteria->equals($criteria)) {
					$this->collCareerStudents = CareerStudentPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCareerStudentCriteria = $criteria;
		return $this->collCareerStudents;
	}

	/**
	 * Returns the number of related CareerStudent objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related CareerStudent objects.
	 * @throws     PropelException
	 */
	public function countCareerStudents(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCareerStudents === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

				$count = CareerStudentPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastCareerStudentCriteria) || !$this->lastCareerStudentCriteria->equals($criteria)) {
					$count = CareerStudentPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collCareerStudents);
				}
			} else {
				$count = count($this->collCareerStudents);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a CareerStudent object to this object
	 * through the CareerStudent foreign key attribute.
	 *
	 * @param      CareerStudent $l CareerStudent
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCareerStudent(CareerStudent $l)
	{
		if ($this->collCareerStudents === null) {
			$this->initCareerStudents();
		}
		if (!in_array($l, $this->collCareerStudents, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCareerStudents, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related CareerStudents from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getCareerStudentsJoinCareer($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCareerStudents === null) {
			if ($this->isNew()) {
				$this->collCareerStudents = array();
			} else {

				$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

				$this->collCareerStudents = CareerStudentPeer::doSelectJoinCareer($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastCareerStudentCriteria) || !$this->lastCareerStudentCriteria->equals($criteria)) {
				$this->collCareerStudents = CareerStudentPeer::doSelectJoinCareer($criteria, $con, $join_behavior);
			}
		}
		$this->lastCareerStudentCriteria = $criteria;

		return $this->collCareerStudents;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related CareerStudents from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getCareerStudentsJoinOrientation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCareerStudents === null) {
			if ($this->isNew()) {
				$this->collCareerStudents = array();
			} else {

				$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

				$this->collCareerStudents = CareerStudentPeer::doSelectJoinOrientation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastCareerStudentCriteria) || !$this->lastCareerStudentCriteria->equals($criteria)) {
				$this->collCareerStudents = CareerStudentPeer::doSelectJoinOrientation($criteria, $con, $join_behavior);
			}
		}
		$this->lastCareerStudentCriteria = $criteria;

		return $this->collCareerStudents;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related CareerStudents from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getCareerStudentsJoinSubOrientation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCareerStudents === null) {
			if ($this->isNew()) {
				$this->collCareerStudents = array();
			} else {

				$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

				$this->collCareerStudents = CareerStudentPeer::doSelectJoinSubOrientation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastCareerStudentCriteria) || !$this->lastCareerStudentCriteria->equals($criteria)) {
				$this->collCareerStudents = CareerStudentPeer::doSelectJoinSubOrientation($criteria, $con, $join_behavior);
			}
		}
		$this->lastCareerStudentCriteria = $criteria;

		return $this->collCareerStudents;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related CareerStudents from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getCareerStudentsJoinSchoolYear($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCareerStudents === null) {
			if ($this->isNew()) {
				$this->collCareerStudents = array();
			} else {

				$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

				$this->collCareerStudents = CareerStudentPeer::doSelectJoinSchoolYear($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CareerStudentPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastCareerStudentCriteria) || !$this->lastCareerStudentCriteria->equals($criteria)) {
				$this->collCareerStudents = CareerStudentPeer::doSelectJoinSchoolYear($criteria, $con, $join_behavior);
			}
		}
		$this->lastCareerStudentCriteria = $criteria;

		return $this->collCareerStudents;
	}

	/**
	 * Clears out the collStudentCareerSchoolYears collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentCareerSchoolYears()
	 */
	public function clearStudentCareerSchoolYears()
	{
		$this->collStudentCareerSchoolYears = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentCareerSchoolYears collection (array).
	 *
	 * By default this just sets the collStudentCareerSchoolYears collection to an empty array (like clearcollStudentCareerSchoolYears());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentCareerSchoolYears()
	{
		$this->collStudentCareerSchoolYears = array();
	}

	/**
	 * Gets an array of StudentCareerSchoolYear objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentCareerSchoolYears from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentCareerSchoolYear[]
	 * @throws     PropelException
	 */
	public function getStudentCareerSchoolYears($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentCareerSchoolYears === null) {
			if ($this->isNew()) {
			   $this->collStudentCareerSchoolYears = array();
			} else {

				$criteria->add(StudentCareerSchoolYearPeer::STUDENT_ID, $this->id);

				StudentCareerSchoolYearPeer::addSelectColumns($criteria);
				$this->collStudentCareerSchoolYears = StudentCareerSchoolYearPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentCareerSchoolYearPeer::STUDENT_ID, $this->id);

				StudentCareerSchoolYearPeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentCareerSchoolYearCriteria) || !$this->lastStudentCareerSchoolYearCriteria->equals($criteria)) {
					$this->collStudentCareerSchoolYears = StudentCareerSchoolYearPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentCareerSchoolYearCriteria = $criteria;
		return $this->collStudentCareerSchoolYears;
	}

	/**
	 * Returns the number of related StudentCareerSchoolYear objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentCareerSchoolYear objects.
	 * @throws     PropelException
	 */
	public function countStudentCareerSchoolYears(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentCareerSchoolYears === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentCareerSchoolYearPeer::STUDENT_ID, $this->id);

				$count = StudentCareerSchoolYearPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentCareerSchoolYearPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentCareerSchoolYearCriteria) || !$this->lastStudentCareerSchoolYearCriteria->equals($criteria)) {
					$count = StudentCareerSchoolYearPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentCareerSchoolYears);
				}
			} else {
				$count = count($this->collStudentCareerSchoolYears);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentCareerSchoolYear object to this object
	 * through the StudentCareerSchoolYear foreign key attribute.
	 *
	 * @param      StudentCareerSchoolYear $l StudentCareerSchoolYear
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentCareerSchoolYear(StudentCareerSchoolYear $l)
	{
		if ($this->collStudentCareerSchoolYears === null) {
			$this->initStudentCareerSchoolYears();
		}
		if (!in_array($l, $this->collStudentCareerSchoolYears, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentCareerSchoolYears, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentCareerSchoolYears from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentCareerSchoolYearsJoinCareerSchoolYear($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentCareerSchoolYears === null) {
			if ($this->isNew()) {
				$this->collStudentCareerSchoolYears = array();
			} else {

				$criteria->add(StudentCareerSchoolYearPeer::STUDENT_ID, $this->id);

				$this->collStudentCareerSchoolYears = StudentCareerSchoolYearPeer::doSelectJoinCareerSchoolYear($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentCareerSchoolYearPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentCareerSchoolYearCriteria) || !$this->lastStudentCareerSchoolYearCriteria->equals($criteria)) {
				$this->collStudentCareerSchoolYears = StudentCareerSchoolYearPeer::doSelectJoinCareerSchoolYear($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentCareerSchoolYearCriteria = $criteria;

		return $this->collStudentCareerSchoolYears;
	}

	/**
	 * Clears out the collSchoolYearStudents collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addSchoolYearStudents()
	 */
	public function clearSchoolYearStudents()
	{
		$this->collSchoolYearStudents = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collSchoolYearStudents collection (array).
	 *
	 * By default this just sets the collSchoolYearStudents collection to an empty array (like clearcollSchoolYearStudents());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initSchoolYearStudents()
	{
		$this->collSchoolYearStudents = array();
	}

	/**
	 * Gets an array of SchoolYearStudent objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related SchoolYearStudents from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array SchoolYearStudent[]
	 * @throws     PropelException
	 */
	public function getSchoolYearStudents($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collSchoolYearStudents === null) {
			if ($this->isNew()) {
			   $this->collSchoolYearStudents = array();
			} else {

				$criteria->add(SchoolYearStudentPeer::STUDENT_ID, $this->id);

				SchoolYearStudentPeer::addSelectColumns($criteria);
				$this->collSchoolYearStudents = SchoolYearStudentPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(SchoolYearStudentPeer::STUDENT_ID, $this->id);

				SchoolYearStudentPeer::addSelectColumns($criteria);
				if (!isset($this->lastSchoolYearStudentCriteria) || !$this->lastSchoolYearStudentCriteria->equals($criteria)) {
					$this->collSchoolYearStudents = SchoolYearStudentPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastSchoolYearStudentCriteria = $criteria;
		return $this->collSchoolYearStudents;
	}

	/**
	 * Returns the number of related SchoolYearStudent objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related SchoolYearStudent objects.
	 * @throws     PropelException
	 */
	public function countSchoolYearStudents(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collSchoolYearStudents === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(SchoolYearStudentPeer::STUDENT_ID, $this->id);

				$count = SchoolYearStudentPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(SchoolYearStudentPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastSchoolYearStudentCriteria) || !$this->lastSchoolYearStudentCriteria->equals($criteria)) {
					$count = SchoolYearStudentPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collSchoolYearStudents);
				}
			} else {
				$count = count($this->collSchoolYearStudents);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a SchoolYearStudent object to this object
	 * through the SchoolYearStudent foreign key attribute.
	 *
	 * @param      SchoolYearStudent $l SchoolYearStudent
	 * @return     void
	 * @throws     PropelException
	 */
	public function addSchoolYearStudent(SchoolYearStudent $l)
	{
		if ($this->collSchoolYearStudents === null) {
			$this->initSchoolYearStudents();
		}
		if (!in_array($l, $this->collSchoolYearStudents, true)) { // only add it if the **same** object is not already associated
			array_push($this->collSchoolYearStudents, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related SchoolYearStudents from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getSchoolYearStudentsJoinSchoolYear($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collSchoolYearStudents === null) {
			if ($this->isNew()) {
				$this->collSchoolYearStudents = array();
			} else {

				$criteria->add(SchoolYearStudentPeer::STUDENT_ID, $this->id);

				$this->collSchoolYearStudents = SchoolYearStudentPeer::doSelectJoinSchoolYear($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(SchoolYearStudentPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastSchoolYearStudentCriteria) || !$this->lastSchoolYearStudentCriteria->equals($criteria)) {
				$this->collSchoolYearStudents = SchoolYearStudentPeer::doSelectJoinSchoolYear($criteria, $con, $join_behavior);
			}
		}
		$this->lastSchoolYearStudentCriteria = $criteria;

		return $this->collSchoolYearStudents;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related SchoolYearStudents from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getSchoolYearStudentsJoinShift($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collSchoolYearStudents === null) {
			if ($this->isNew()) {
				$this->collSchoolYearStudents = array();
			} else {

				$criteria->add(SchoolYearStudentPeer::STUDENT_ID, $this->id);

				$this->collSchoolYearStudents = SchoolYearStudentPeer::doSelectJoinShift($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(SchoolYearStudentPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastSchoolYearStudentCriteria) || !$this->lastSchoolYearStudentCriteria->equals($criteria)) {
				$this->collSchoolYearStudents = SchoolYearStudentPeer::doSelectJoinShift($criteria, $con, $join_behavior);
			}
		}
		$this->lastSchoolYearStudentCriteria = $criteria;

		return $this->collSchoolYearStudents;
	}

	/**
	 * Clears out the collDivisionStudents collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDivisionStudents()
	 */
	public function clearDivisionStudents()
	{
		$this->collDivisionStudents = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDivisionStudents collection (array).
	 *
	 * By default this just sets the collDivisionStudents collection to an empty array (like clearcollDivisionStudents());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDivisionStudents()
	{
		$this->collDivisionStudents = array();
	}

	/**
	 * Gets an array of DivisionStudent objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related DivisionStudents from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array DivisionStudent[]
	 * @throws     PropelException
	 */
	public function getDivisionStudents($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDivisionStudents === null) {
			if ($this->isNew()) {
			   $this->collDivisionStudents = array();
			} else {

				$criteria->add(DivisionStudentPeer::STUDENT_ID, $this->id);

				DivisionStudentPeer::addSelectColumns($criteria);
				$this->collDivisionStudents = DivisionStudentPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DivisionStudentPeer::STUDENT_ID, $this->id);

				DivisionStudentPeer::addSelectColumns($criteria);
				if (!isset($this->lastDivisionStudentCriteria) || !$this->lastDivisionStudentCriteria->equals($criteria)) {
					$this->collDivisionStudents = DivisionStudentPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDivisionStudentCriteria = $criteria;
		return $this->collDivisionStudents;
	}

	/**
	 * Returns the number of related DivisionStudent objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related DivisionStudent objects.
	 * @throws     PropelException
	 */
	public function countDivisionStudents(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDivisionStudents === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DivisionStudentPeer::STUDENT_ID, $this->id);

				$count = DivisionStudentPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DivisionStudentPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastDivisionStudentCriteria) || !$this->lastDivisionStudentCriteria->equals($criteria)) {
					$count = DivisionStudentPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collDivisionStudents);
				}
			} else {
				$count = count($this->collDivisionStudents);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a DivisionStudent object to this object
	 * through the DivisionStudent foreign key attribute.
	 *
	 * @param      DivisionStudent $l DivisionStudent
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDivisionStudent(DivisionStudent $l)
	{
		if ($this->collDivisionStudents === null) {
			$this->initDivisionStudents();
		}
		if (!in_array($l, $this->collDivisionStudents, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDivisionStudents, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related DivisionStudents from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getDivisionStudentsJoinDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDivisionStudents === null) {
			if ($this->isNew()) {
				$this->collDivisionStudents = array();
			} else {

				$criteria->add(DivisionStudentPeer::STUDENT_ID, $this->id);

				$this->collDivisionStudents = DivisionStudentPeer::doSelectJoinDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DivisionStudentPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastDivisionStudentCriteria) || !$this->lastDivisionStudentCriteria->equals($criteria)) {
				$this->collDivisionStudents = DivisionStudentPeer::doSelectJoinDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastDivisionStudentCriteria = $criteria;

		return $this->collDivisionStudents;
	}

	/**
	 * Clears out the collStudentDisciplinarySanctions collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentDisciplinarySanctions()
	 */
	public function clearStudentDisciplinarySanctions()
	{
		$this->collStudentDisciplinarySanctions = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentDisciplinarySanctions collection (array).
	 *
	 * By default this just sets the collStudentDisciplinarySanctions collection to an empty array (like clearcollStudentDisciplinarySanctions());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentDisciplinarySanctions()
	{
		$this->collStudentDisciplinarySanctions = array();
	}

	/**
	 * Gets an array of StudentDisciplinarySanction objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentDisciplinarySanctions from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentDisciplinarySanction[]
	 * @throws     PropelException
	 */
	public function getStudentDisciplinarySanctions($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentDisciplinarySanctions === null) {
			if ($this->isNew()) {
			   $this->collStudentDisciplinarySanctions = array();
			} else {

				$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

				StudentDisciplinarySanctionPeer::addSelectColumns($criteria);
				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

				StudentDisciplinarySanctionPeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentDisciplinarySanctionCriteria) || !$this->lastStudentDisciplinarySanctionCriteria->equals($criteria)) {
					$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentDisciplinarySanctionCriteria = $criteria;
		return $this->collStudentDisciplinarySanctions;
	}

	/**
	 * Returns the number of related StudentDisciplinarySanction objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentDisciplinarySanction objects.
	 * @throws     PropelException
	 */
	public function countStudentDisciplinarySanctions(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentDisciplinarySanctions === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

				$count = StudentDisciplinarySanctionPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentDisciplinarySanctionCriteria) || !$this->lastStudentDisciplinarySanctionCriteria->equals($criteria)) {
					$count = StudentDisciplinarySanctionPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentDisciplinarySanctions);
				}
			} else {
				$count = count($this->collStudentDisciplinarySanctions);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentDisciplinarySanction object to this object
	 * through the StudentDisciplinarySanction foreign key attribute.
	 *
	 * @param      StudentDisciplinarySanction $l StudentDisciplinarySanction
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentDisciplinarySanction(StudentDisciplinarySanction $l)
	{
		if ($this->collStudentDisciplinarySanctions === null) {
			$this->initStudentDisciplinarySanctions();
		}
		if (!in_array($l, $this->collStudentDisciplinarySanctions, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentDisciplinarySanctions, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentDisciplinarySanctions from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentDisciplinarySanctionsJoinDisciplinarySanctionType($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentDisciplinarySanctions === null) {
			if ($this->isNew()) {
				$this->collStudentDisciplinarySanctions = array();
			} else {

				$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelectJoinDisciplinarySanctionType($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentDisciplinarySanctionCriteria) || !$this->lastStudentDisciplinarySanctionCriteria->equals($criteria)) {
				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelectJoinDisciplinarySanctionType($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentDisciplinarySanctionCriteria = $criteria;

		return $this->collStudentDisciplinarySanctions;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentDisciplinarySanctions from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentDisciplinarySanctionsJoinSanctionType($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentDisciplinarySanctions === null) {
			if ($this->isNew()) {
				$this->collStudentDisciplinarySanctions = array();
			} else {

				$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelectJoinSanctionType($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentDisciplinarySanctionCriteria) || !$this->lastStudentDisciplinarySanctionCriteria->equals($criteria)) {
				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelectJoinSanctionType($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentDisciplinarySanctionCriteria = $criteria;

		return $this->collStudentDisciplinarySanctions;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentDisciplinarySanctions from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentDisciplinarySanctionsJoinPersonRelatedByApplicantId($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentDisciplinarySanctions === null) {
			if ($this->isNew()) {
				$this->collStudentDisciplinarySanctions = array();
			} else {

				$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelectJoinPersonRelatedByApplicantId($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentDisciplinarySanctionCriteria) || !$this->lastStudentDisciplinarySanctionCriteria->equals($criteria)) {
				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelectJoinPersonRelatedByApplicantId($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentDisciplinarySanctionCriteria = $criteria;

		return $this->collStudentDisciplinarySanctions;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentDisciplinarySanctions from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentDisciplinarySanctionsJoinPersonRelatedByResponsibleId($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentDisciplinarySanctions === null) {
			if ($this->isNew()) {
				$this->collStudentDisciplinarySanctions = array();
			} else {

				$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelectJoinPersonRelatedByResponsibleId($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentDisciplinarySanctionCriteria) || !$this->lastStudentDisciplinarySanctionCriteria->equals($criteria)) {
				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelectJoinPersonRelatedByResponsibleId($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentDisciplinarySanctionCriteria = $criteria;

		return $this->collStudentDisciplinarySanctions;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentDisciplinarySanctions from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentDisciplinarySanctionsJoinSchoolYear($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentDisciplinarySanctions === null) {
			if ($this->isNew()) {
				$this->collStudentDisciplinarySanctions = array();
			} else {

				$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelectJoinSchoolYear($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentDisciplinarySanctionPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentDisciplinarySanctionCriteria) || !$this->lastStudentDisciplinarySanctionCriteria->equals($criteria)) {
				$this->collStudentDisciplinarySanctions = StudentDisciplinarySanctionPeer::doSelectJoinSchoolYear($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentDisciplinarySanctionCriteria = $criteria;

		return $this->collStudentDisciplinarySanctions;
	}

	/**
	 * Clears out the collBrotherhoodsRelatedByStudentId collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addBrotherhoodsRelatedByStudentId()
	 */
	public function clearBrotherhoodsRelatedByStudentId()
	{
		$this->collBrotherhoodsRelatedByStudentId = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collBrotherhoodsRelatedByStudentId collection (array).
	 *
	 * By default this just sets the collBrotherhoodsRelatedByStudentId collection to an empty array (like clearcollBrotherhoodsRelatedByStudentId());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initBrotherhoodsRelatedByStudentId()
	{
		$this->collBrotherhoodsRelatedByStudentId = array();
	}

	/**
	 * Gets an array of Brotherhood objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related BrotherhoodsRelatedByStudentId from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Brotherhood[]
	 * @throws     PropelException
	 */
	public function getBrotherhoodsRelatedByStudentId($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collBrotherhoodsRelatedByStudentId === null) {
			if ($this->isNew()) {
			   $this->collBrotherhoodsRelatedByStudentId = array();
			} else {

				$criteria->add(BrotherhoodPeer::STUDENT_ID, $this->id);

				BrotherhoodPeer::addSelectColumns($criteria);
				$this->collBrotherhoodsRelatedByStudentId = BrotherhoodPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(BrotherhoodPeer::STUDENT_ID, $this->id);

				BrotherhoodPeer::addSelectColumns($criteria);
				if (!isset($this->lastBrotherhoodRelatedByStudentIdCriteria) || !$this->lastBrotherhoodRelatedByStudentIdCriteria->equals($criteria)) {
					$this->collBrotherhoodsRelatedByStudentId = BrotherhoodPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastBrotherhoodRelatedByStudentIdCriteria = $criteria;
		return $this->collBrotherhoodsRelatedByStudentId;
	}

	/**
	 * Returns the number of related Brotherhood objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Brotherhood objects.
	 * @throws     PropelException
	 */
	public function countBrotherhoodsRelatedByStudentId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collBrotherhoodsRelatedByStudentId === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(BrotherhoodPeer::STUDENT_ID, $this->id);

				$count = BrotherhoodPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(BrotherhoodPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastBrotherhoodRelatedByStudentIdCriteria) || !$this->lastBrotherhoodRelatedByStudentIdCriteria->equals($criteria)) {
					$count = BrotherhoodPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collBrotherhoodsRelatedByStudentId);
				}
			} else {
				$count = count($this->collBrotherhoodsRelatedByStudentId);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Brotherhood object to this object
	 * through the Brotherhood foreign key attribute.
	 *
	 * @param      Brotherhood $l Brotherhood
	 * @return     void
	 * @throws     PropelException
	 */
	public function addBrotherhoodRelatedByStudentId(Brotherhood $l)
	{
		if ($this->collBrotherhoodsRelatedByStudentId === null) {
			$this->initBrotherhoodsRelatedByStudentId();
		}
		if (!in_array($l, $this->collBrotherhoodsRelatedByStudentId, true)) { // only add it if the **same** object is not already associated
			array_push($this->collBrotherhoodsRelatedByStudentId, $l);
			$l->setStudentRelatedByStudentId($this);
		}
	}

	/**
	 * Clears out the collBrotherhoodsRelatedByBrotherId collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addBrotherhoodsRelatedByBrotherId()
	 */
	public function clearBrotherhoodsRelatedByBrotherId()
	{
		$this->collBrotherhoodsRelatedByBrotherId = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collBrotherhoodsRelatedByBrotherId collection (array).
	 *
	 * By default this just sets the collBrotherhoodsRelatedByBrotherId collection to an empty array (like clearcollBrotherhoodsRelatedByBrotherId());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initBrotherhoodsRelatedByBrotherId()
	{
		$this->collBrotherhoodsRelatedByBrotherId = array();
	}

	/**
	 * Gets an array of Brotherhood objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related BrotherhoodsRelatedByBrotherId from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Brotherhood[]
	 * @throws     PropelException
	 */
	public function getBrotherhoodsRelatedByBrotherId($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collBrotherhoodsRelatedByBrotherId === null) {
			if ($this->isNew()) {
			   $this->collBrotherhoodsRelatedByBrotherId = array();
			} else {

				$criteria->add(BrotherhoodPeer::BROTHER_ID, $this->id);

				BrotherhoodPeer::addSelectColumns($criteria);
				$this->collBrotherhoodsRelatedByBrotherId = BrotherhoodPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(BrotherhoodPeer::BROTHER_ID, $this->id);

				BrotherhoodPeer::addSelectColumns($criteria);
				if (!isset($this->lastBrotherhoodRelatedByBrotherIdCriteria) || !$this->lastBrotherhoodRelatedByBrotherIdCriteria->equals($criteria)) {
					$this->collBrotherhoodsRelatedByBrotherId = BrotherhoodPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastBrotherhoodRelatedByBrotherIdCriteria = $criteria;
		return $this->collBrotherhoodsRelatedByBrotherId;
	}

	/**
	 * Returns the number of related Brotherhood objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Brotherhood objects.
	 * @throws     PropelException
	 */
	public function countBrotherhoodsRelatedByBrotherId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collBrotherhoodsRelatedByBrotherId === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(BrotherhoodPeer::BROTHER_ID, $this->id);

				$count = BrotherhoodPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(BrotherhoodPeer::BROTHER_ID, $this->id);

				if (!isset($this->lastBrotherhoodRelatedByBrotherIdCriteria) || !$this->lastBrotherhoodRelatedByBrotherIdCriteria->equals($criteria)) {
					$count = BrotherhoodPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collBrotherhoodsRelatedByBrotherId);
				}
			} else {
				$count = count($this->collBrotherhoodsRelatedByBrotherId);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Brotherhood object to this object
	 * through the Brotherhood foreign key attribute.
	 *
	 * @param      Brotherhood $l Brotherhood
	 * @return     void
	 * @throws     PropelException
	 */
	public function addBrotherhoodRelatedByBrotherId(Brotherhood $l)
	{
		if ($this->collBrotherhoodsRelatedByBrotherId === null) {
			$this->initBrotherhoodsRelatedByBrotherId();
		}
		if (!in_array($l, $this->collBrotherhoodsRelatedByBrotherId, true)) { // only add it if the **same** object is not already associated
			array_push($this->collBrotherhoodsRelatedByBrotherId, $l);
			$l->setStudentRelatedByBrotherId($this);
		}
	}

	/**
	 * Clears out the collStudentTags collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentTags()
	 */
	public function clearStudentTags()
	{
		$this->collStudentTags = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentTags collection (array).
	 *
	 * By default this just sets the collStudentTags collection to an empty array (like clearcollStudentTags());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentTags()
	{
		$this->collStudentTags = array();
	}

	/**
	 * Gets an array of StudentTag objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentTags from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentTag[]
	 * @throws     PropelException
	 */
	public function getStudentTags($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentTags === null) {
			if ($this->isNew()) {
			   $this->collStudentTags = array();
			} else {

				$criteria->add(StudentTagPeer::STUDENT_ID, $this->id);

				StudentTagPeer::addSelectColumns($criteria);
				$this->collStudentTags = StudentTagPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentTagPeer::STUDENT_ID, $this->id);

				StudentTagPeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentTagCriteria) || !$this->lastStudentTagCriteria->equals($criteria)) {
					$this->collStudentTags = StudentTagPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentTagCriteria = $criteria;
		return $this->collStudentTags;
	}

	/**
	 * Returns the number of related StudentTag objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentTag objects.
	 * @throws     PropelException
	 */
	public function countStudentTags(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentTags === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentTagPeer::STUDENT_ID, $this->id);

				$count = StudentTagPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentTagPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentTagCriteria) || !$this->lastStudentTagCriteria->equals($criteria)) {
					$count = StudentTagPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentTags);
				}
			} else {
				$count = count($this->collStudentTags);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentTag object to this object
	 * through the StudentTag foreign key attribute.
	 *
	 * @param      StudentTag $l StudentTag
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentTag(StudentTag $l)
	{
		if ($this->collStudentTags === null) {
			$this->initStudentTags();
		}
		if (!in_array($l, $this->collStudentTags, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentTags, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentTags from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentTagsJoinTag($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentTags === null) {
			if ($this->isNew()) {
				$this->collStudentTags = array();
			} else {

				$criteria->add(StudentTagPeer::STUDENT_ID, $this->id);

				$this->collStudentTags = StudentTagPeer::doSelectJoinTag($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentTagPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentTagCriteria) || !$this->lastStudentTagCriteria->equals($criteria)) {
				$this->collStudentTags = StudentTagPeer::doSelectJoinTag($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentTagCriteria = $criteria;

		return $this->collStudentTags;
	}

	/**
	 * Clears out the collStudentTutors collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStudentTutors()
	 */
	public function clearStudentTutors()
	{
		$this->collStudentTutors = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStudentTutors collection (array).
	 *
	 * By default this just sets the collStudentTutors collection to an empty array (like clearcollStudentTutors());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStudentTutors()
	{
		$this->collStudentTutors = array();
	}

	/**
	 * Gets an array of StudentTutor objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Student has previously been saved, it will retrieve
	 * related StudentTutors from storage. If this Student is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array StudentTutor[]
	 * @throws     PropelException
	 */
	public function getStudentTutors($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentTutors === null) {
			if ($this->isNew()) {
			   $this->collStudentTutors = array();
			} else {

				$criteria->add(StudentTutorPeer::STUDENT_ID, $this->id);

				StudentTutorPeer::addSelectColumns($criteria);
				$this->collStudentTutors = StudentTutorPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StudentTutorPeer::STUDENT_ID, $this->id);

				StudentTutorPeer::addSelectColumns($criteria);
				if (!isset($this->lastStudentTutorCriteria) || !$this->lastStudentTutorCriteria->equals($criteria)) {
					$this->collStudentTutors = StudentTutorPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStudentTutorCriteria = $criteria;
		return $this->collStudentTutors;
	}

	/**
	 * Returns the number of related StudentTutor objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related StudentTutor objects.
	 * @throws     PropelException
	 */
	public function countStudentTutors(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStudentTutors === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StudentTutorPeer::STUDENT_ID, $this->id);

				$count = StudentTutorPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StudentTutorPeer::STUDENT_ID, $this->id);

				if (!isset($this->lastStudentTutorCriteria) || !$this->lastStudentTutorCriteria->equals($criteria)) {
					$count = StudentTutorPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStudentTutors);
				}
			} else {
				$count = count($this->collStudentTutors);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a StudentTutor object to this object
	 * through the StudentTutor foreign key attribute.
	 *
	 * @param      StudentTutor $l StudentTutor
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStudentTutor(StudentTutor $l)
	{
		if ($this->collStudentTutors === null) {
			$this->initStudentTutors();
		}
		if (!in_array($l, $this->collStudentTutors, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStudentTutors, $l);
			$l->setStudent($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Student is new, it will return
	 * an empty collection; or if this Student has previously
	 * been saved, it will retrieve related StudentTutors from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Student.
	 */
	public function getStudentTutorsJoinTutor($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(StudentPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStudentTutors === null) {
			if ($this->isNew()) {
				$this->collStudentTutors = array();
			} else {

				$criteria->add(StudentTutorPeer::STUDENT_ID, $this->id);

				$this->collStudentTutors = StudentTutorPeer::doSelectJoinTutor($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StudentTutorPeer::STUDENT_ID, $this->id);

			if (!isset($this->lastStudentTutorCriteria) || !$this->lastStudentTutorCriteria->equals($criteria)) {
				$this->collStudentTutors = StudentTutorPeer::doSelectJoinTutor($criteria, $con, $join_behavior);
			}
		}
		$this->lastStudentTutorCriteria = $criteria;

		return $this->collStudentTutors;
	}

	/**
	 * Resets all collections of referencing foreign keys.
	 *
	 * This method is a user-space workaround for PHP's inability to garbage collect objects
	 * with circular references.  This is currently necessary when using Propel in certain
	 * daemon or large-volumne/high-memory operations.
	 *
	 * @param      boolean $deep Whether to also clear the references on all associated objects.
	 */
	public function clearAllReferences($deep = false)
	{
		if ($deep) {
			if ($this->collStudentCareerSubjectAlloweds) {
				foreach ((array) $this->collStudentCareerSubjectAlloweds as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCourseSubjectStudents) {
				foreach ((array) $this->collCourseSubjectStudents as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStudentApprovedCareerSubjects) {
				foreach ((array) $this->collStudentApprovedCareerSubjects as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStudentApprovedCourseSubjects) {
				foreach ((array) $this->collStudentApprovedCourseSubjects as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStudentStudys) {
				foreach ((array) $this->collStudentStudys as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStudentAttendances) {
				foreach ((array) $this->collStudentAttendances as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStudentReincorporations) {
				foreach ((array) $this->collStudentReincorporations as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStudentFrees) {
				foreach ((array) $this->collStudentFrees as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collPathwayStudents) {
				foreach ((array) $this->collPathwayStudents as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCourseSubjectStudentPathways) {
				foreach ((array) $this->collCourseSubjectStudentPathways as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCareerStudents) {
				foreach ((array) $this->collCareerStudents as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStudentCareerSchoolYears) {
				foreach ((array) $this->collStudentCareerSchoolYears as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collSchoolYearStudents) {
				foreach ((array) $this->collSchoolYearStudents as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDivisionStudents) {
				foreach ((array) $this->collDivisionStudents as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStudentDisciplinarySanctions) {
				foreach ((array) $this->collStudentDisciplinarySanctions as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collBrotherhoodsRelatedByStudentId) {
				foreach ((array) $this->collBrotherhoodsRelatedByStudentId as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collBrotherhoodsRelatedByBrotherId) {
				foreach ((array) $this->collBrotherhoodsRelatedByBrotherId as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStudentTags) {
				foreach ((array) $this->collStudentTags as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStudentTutors) {
				foreach ((array) $this->collStudentTutors as $o) {
					$o->clearAllReferences($deep);
				}
			}
		} // if ($deep)

		$this->collStudentCareerSubjectAlloweds = null;
		$this->collCourseSubjectStudents = null;
		$this->collStudentApprovedCareerSubjects = null;
		$this->collStudentApprovedCourseSubjects = null;
		$this->collStudentStudys = null;
		$this->collStudentAttendances = null;
		$this->collStudentReincorporations = null;
		$this->collStudentFrees = null;
		$this->collPathwayStudents = null;
		$this->collCourseSubjectStudentPathways = null;
		$this->collCareerStudents = null;
		$this->collStudentCareerSchoolYears = null;
		$this->collSchoolYearStudents = null;
		$this->collDivisionStudents = null;
		$this->collStudentDisciplinarySanctions = null;
		$this->collBrotherhoodsRelatedByStudentId = null;
		$this->collBrotherhoodsRelatedByBrotherId = null;
		$this->collStudentTags = null;
		$this->collStudentTutors = null;
			$this->aPerson = null;
			$this->aOccupation = null;
			$this->aHealthCoverage = null;
	}


  public function __call($method, $arguments)
  {
    if (!$callable = sfMixer::getCallable('BaseStudent:'.$method))
    {
      throw new sfException(sprintf('Call to undefined method BaseStudent::%s', $method));
    }

    array_unshift($arguments, $this);

    return call_user_func_array($callable, $arguments);
  }


} // BaseStudent
